


<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>CSG Editor - Mobile</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                font-family: 'Segoe UI', sans-serif;
                background: #1e1e1e;
                color: white;
            }

            #toolbar {
                display: flex;
                background: #2c3e50;
                color: white;
                padding: 0;
                gap: 0;
                justify-content: center;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                z-index: 10;
                position: relative;
            }

            #toolbar button {
                background: #3498db;
                color: white;
                border: none;
                font-size: 1em;
                width: 35px;
                height: 35px;
                cursor: pointer;
                transition: background 0.2s, transform 0.1s;
                box-shadow: none;
                border-radius: 0;
            }

            #toolbar button:active {
                transform: scale(0.95);
            }

            #toolbar button:hover {
                background: #2980b9;
            }

            .toolbar-separator {
                width: 1px;
                background-color: #446688;
                height: 35px;
            }

            #main-container {
                width: 100%;
                height: calc(100vh - 35px);
                position: relative;
            }

            #code-panel,
            #view-panel,
            #settings-panel,
            #editor-code-panel {
                position: absolute;
                width: 100%;
                height: 100%;
                display: none;
                background: white;
            }

            #code-panel,
            #editor-code-panel {
                background: #1e1e1e;
                color: #f8f8f8;
            }

            #settings-panel {
                background: #282c34;
                color: #f8f8f8;
                padding: 20px;
                box-sizing: border-box;
                overflow-y: auto;
            }

            #settings-panel h2 {
                color: #61afef;
                border-bottom: 2px solid #545862;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }

            #settings-panel label {
                font-size: 1em;
                color: #a0a0a0;
                margin-bottom: 5px;
            }

            #settings-panel input[type='number'],
            #settings-panel input[type='text'] {
                width: 80px;
                padding: 5px;
                background: #3e4451;
                border: 1px solid #545862;
                color: #f8f8f8;
                border-radius: 4px;
                margin-left: 10px;
            }

            #save-settings-btn {
                background: #28a745;
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 20px;
            }

            #save-settings-btn:hover {
                background: #218838;
            }
            
            #clear-cache-btn {
                background: #dc3545;
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 20px;
            }
            
            #clear-cache-btn:hover {
                background: #c82333;
            }

            #three-canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            }

            .modal-content {
                background: #282c34;
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
            }
        </style>

        <script type="importmap">
            {
                "imports": {
                    "three": "./build/three.module.js",
                    "three/addons/": "./jsm/",
                    "three-mesh-bvh": "./js/mesh-bvh.js",
                    "three-bvh-csg": "./js/csg-bvh.js"
                }
            }
        </script>
    </head>
    <body>
        <div id="toolbar">
            <button id="btn-3d" title="3D View">&#x1F5BC;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-code" title="CSG Code Editor">&#x1F4BB;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-editor-code" title="Editor Code">&#x2B9D;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-settings" title="Settings">&#x2699;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-load" title="Load Project">&#x1F4E5;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-save" title="Save Project">&#x1F4BE;</button>
        </div>

        <div id="main-container">
            <div id="code-panel">
                <textcode
                    id="csg-code"
                    title="CSG Script"
                    onrun="runCSGCode();">
                    // Edit and save to update!
/*
return floor(
	difference(
		color(0x0000ffff,sphere({ r: 20, fn:100 })),
		translate([15, 0, 0], cube([20, 20, 20])),
		translate([0, 0, 15], cylinder({ r: 20, h: 30 , fn:100}))
	)
);
*/
//return cube([40, 50, 60]);
/*
var b1= floor(
	translate([30,0,0],
		cylinder({d:10, h:20, fn:50})
	)
);

var b2= floor(
	translate([0,0,0],
		cube([10,10,10])
	)
);

return {
	b1:{
	data:b1,
	show:true
	},
	b2:{
		data:b2,
		show:true
		}
	};
	*/
	
	return translate([30,0,0],
	union(
	
	translate([5,5,0],
		color(0xffff0000, cube([10,10,10]))
	),
	translate([0,0,0],
		cube([10,10,10])
	)
	
	)
	);
	
	
                </textcode>
            </div>

            <div id="editor-code-panel">
                <textcode
                    id="editor-code"
                    title="Editor Script"
					onrun="runEditorScript();">
                    // Place reusable functions and objects here.
                    // Access from CSG Script with include("page name");
                    /*
                    var constants = {
                        PI: Math.PI,
                        E: Math.E
                    };
                    return { constants };
                    */
                </textcode>
            </div>

            <div id="view-panel">
                <canvas id="three-canvas"></canvas>
            </div>

            <div id="settings-panel">
                <h2>Settings</h2>
                <label for="width-input">Grid Width:</label>
                <input type="number" id="width-input" value="220" />
                mm<br /><br />
                <label for="length-input">Grid Length:</label>
                <input type="number" id="length-input" value="220" />
                mm<br /><br />
                <label for="grid-size-input">Grid Spacing:</label>
                <input type="number" id="grid-size-input" value="10" />
                mm<br /><br />
                <label for="library-path-input">Library Path:</label>
                <input type="text" id="library-path-input" value="/csgLib" /><br /><br />
                <button id="save-settings-btn">Save Settings</button>
                <button id="clear-cache-btn">Clear All Cache</button>
            </div>
        </div>

        <div id="load-code-modal" class="modal-overlay">
            <div class="modal-content">
                <filepicker
                    id="load-picker"
                    useFileButtonText="Load Code"
                    onfilepick="handleLoadFile(event, filePath)"
                    oncancel="closeModal('load-code-modal')">
                </filepicker>
            </div>
        </div>

        <div id="save-code-modal" class="modal-overlay">
            <div class="modal-content">
                <filepicker
                    id="save-picker"
                    useFileButtonText="Save Code"
                    onfilepick="handleSaveFile(event, filePath)"
                    oncancel="closeModal('save-code-modal')">
                </filepicker>
            </div>
        </div>

        <div id="save-stl-modal" class="modal-overlay">
            <div class="modal-content">
                <filepicker
                    id="save-stl-picker"
                    useFileButtonText="Save STL"
                    onfilepick="handleSaveStl(event, filePath)"
                    oncancel="closeModal('save-stl-modal')">
                </filepicker>
            </div>
        </div>

        <script type="module" src="/ux/textCode.js"></script>
        <script type="module" src="/ux/filePicker.js"></script>
        
        <script type="module">
            import * as THREE from 'three'
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { STLExporter } from 'three/addons/exporters/STLExporter.js'
            import { 
                sphere, cube, cylinder, union, difference, intersect, 
                translate, rotate, scale, color, floor, convexHull, align, 
                line3d, linePaths3d, scaleTo
            } from './js/scadCSG.js';
            import { Brush } from 'three-bvh-csg'
            import { api } from '/js/apiCalls.js'

            // Declare global variables
            let settings
            let currentObjects
            const meshCache = {}
            const codeCache = {}
            const exporter = new STLExporter()
            let csgEditor
            let editorCodeEditor
			
            // --- Three.js Setup ---
            const canvas = document.getElementById('three-canvas')
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true
            })
            renderer.setClearColor(0x1e1e1e)

            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.01,
                2000
            )

            camera.position.set(0, 50, 50)
            camera.lookAt(0, 0, 0)

            const controls = new OrbitControls(camera, canvas)
            controls.enableDamping = true
            controls.dampingFactor = 0.1

            // --- 3-Point Lighting ---
            const keyLight = new THREE.PointLight(0xffffff, 7, 1000, 0.2)
            const ambientLight = new THREE.AmbientLight(0xffcc66, 0.5)
            scene.add(keyLight, ambientLight)

            // --- Vertical Line at Origin (Y-axis) ---
            const originLineMaterial = new THREE.LineBasicMaterial({
                color: 0x555555
            })
            const originLineGeometry = new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(0, -100, 0), new THREE.Vector3(0, 500, 0)]
            )
            const originLine = new THREE.LineSegments(
                originLineGeometry,
                originLineMaterial
            )
            scene.add(originLine)

            // --- Flat Grid & Bounding Box ---
            let buildPlateGrid = null
            let buildPlateBox = null

            function createBuildPlate() {
                if (buildPlateGrid) {
                    scene.remove(buildPlateGrid)
                    buildPlateGrid.geometry.dispose()
                    buildPlateGrid = null
                }
                if (buildPlateBox) {
                    scene.remove(buildPlateBox)
                    buildPlateBox.geometry.dispose()
                    buildPlateBox = null
                }

                const plateSize = Math.max(
                    settings.plateWidth,
                    settings.plateLength
                )
                const divisions = Math.floor(plateSize / settings.gridSize)
                buildPlateGrid = new THREE.GridHelper(
                    plateSize,
                    divisions,
                    0x555555,
                    0x555555
                )
                buildPlateGrid.position.y = 0
                scene.add(buildPlateGrid)

                const boxMaterial = new THREE.LineBasicMaterial({
                    color: 0xcccccc
                })
                const boxGeometry = new THREE.BufferGeometry()
                const halfWidth = settings.plateWidth / 2
                const halfLength = settings.plateLength / 2
                const boxVertices = new Float32Array([
                    -halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    halfLength,
                    halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    -halfLength
                ])
                boxGeometry.setAttribute(
                    'position',
                    new THREE.BufferAttribute(boxVertices, 3)
                )
                buildPlateBox = new THREE.LineSegments(boxGeometry, boxMaterial)
                scene.add(buildPlateBox)
            }

            function resizeRenderer() {
                const width = window.innerWidth
                const height = window.innerHeight - 35
                renderer.setSize(width, height)
                camera.aspect = width / height
                camera.updateProjectionMatrix()
            }
            
            // --- NEW path function ---
            function path(filepath) {
                // Check for absolute path
                if (filepath.startsWith('/')) {
                    return filepath;
                }
            
                // Check for library path
                const libraryPath = settings.libraryPath || '/csgLib';
                if (filepath.startsWith('$lib/')) {
                    return libraryPath + '/' + filepath.substring(5);
                }
            
                // Handle relative path (./ and ../)
                if (!csgEditor.basePath) {
                    alert("Error: Cannot use relative paths. Please load or save a project first to establish a base path.");
                    return null;
                }
                
                const currentDirectory = csgEditor.basePath;
                const parts = currentDirectory.split('/').filter(p => p !== '');
                const fileParts = filepath.split('/');
            
                for (const part of fileParts) {
                    if (part === '..') {
                        if (parts.length > 0) {
                            parts.pop();
                        }
                    } else if (part !== '.' && part !== '') {
                        parts.push(part);
                    }
                }
            
                return '/' + parts.join('/');
            }

            // --- View Management ---
            function showView(id) {
                const codePanel = document.getElementById('code-panel')
                const viewPanel = document.getElementById('view-panel')
                const settingsPanel = document.getElementById('settings-panel')
                const editorCodePanel = document.getElementById('editor-code-panel')
                
                const btn3D = document.getElementById('btn-3d')
                const btnCode = document.getElementById('btn-code')
                const btnEditorCode = document.getElementById('btn-editor-code')
                const btnSettings = document.getElementById('btn-settings')

                codePanel.style.display = 'none'
                viewPanel.style.display = 'none'
                settingsPanel.style.display = 'none'
                editorCodePanel.style.display = 'none'
                
                btn3D.style.backgroundColor = '#3498db'
                btnCode.style.backgroundColor = '#3498db'
                btnEditorCode.style.backgroundColor = '#3498db'
                btnSettings.style.backgroundColor = '#3498db'

                if (id === '3d') {
                    viewPanel.style.display = 'block'
                    btn3D.style.backgroundColor = '#e74c3c'
                } else if (id === 'code') {
                    codePanel.style.display = 'block'
                    btnCode.style.backgroundColor = '#e74c3c'
                } else if (id === 'editor-code') {
                    editorCodePanel.style.display = 'block'
                    btnEditorCode.style.backgroundColor = '#e74c3c'
                } else if (id === 'settings') {
                    settingsPanel.style.display = 'block'
                    btnSettings.style.backgroundColor = '#e74c3c'
                }
            }
			
            // --- Modal Functions ---
            window.openModal = (id) => {
                document.getElementById(id).style.display = 'flex'
            }

            window.closeModal = (id) => {
                document.getElementById(id).style.display = 'none'
            }

            // --- Three.js loaders for handling JSON parsing ---
            window.handleLoadFile = async (event, filePath) => {
                try {
                    const fileContent = await api.readFile(filePath)
                    const projectData = JSON.parse(fileContent)

                    // NEW: Set the base path for relative path calculations
                    const pathSegments = filePath.split('/');
                    pathSegments.pop(); // Remove the file name
                    csgEditor.basePath = pathSegments.join('/') + '/';
                    
                    if (projectData.csgCode) {
                        csgEditor.values = projectData.csgCode
                        csgEditor.setAttribute('active', '0')
                    }
                    if (projectData.editorCode) {
                        editorCodeEditor.values = projectData.editorCode
                        editorCodeEditor.setAttribute('active', '0')
                    }

                    const objectLoader = new THREE.ObjectLoader()
                    if (projectData.meshCache) {
                        for (const pageName in projectData.meshCache) {
                            const cachedData = projectData.meshCache[pageName]
                            let rehydratedMesh = null

                            if (cachedData.mesh) {
                                if (cachedData.mesh.isBrush) {
                                    const mesh = objectLoader.parse(
                                        cachedData.mesh.mesh
                                    )
                                    rehydratedMesh = new Brush(mesh)
                                } else if (
                                    cachedData.mesh.geometries ||
                                    cachedData.mesh.object
                                ) {
                                    rehydratedMesh = objectLoader.parse(
                                        cachedData.mesh
                                    )
                                } else if (
                                    typeof cachedData.mesh === 'object' &&
                                    cachedData.mesh !== null
                                ) {
                                    const rehydratedSubmeshes = {}
                                    for (const subKey in cachedData.mesh) {
                                        const item = cachedData.mesh[subKey]
                                        if (item && item.data) {
                                            let subMesh = null
                                            if (item.data.isBrush) {
                                                const mesh = objectLoader.parse(
                                                    item.data.mesh
                                                )
                                                subMesh = new Brush(mesh)
                                            } else {
                                                subMesh = objectLoader.parse(
                                                    item.data
                                                )
                                            }
                                            rehydratedSubmeshes[subKey] = {
                                                data: subMesh,
                                                show: item.show
                                            }
                                        }
                                    }
                                    rehydratedMesh = rehydratedSubmeshes
                                }
                            }

                            meshCache[pageName] = {
                                mesh: rehydratedMesh,
                                updated: true
                            }
                        }
                    }

                    const csgEditorValues = csgEditor.values
                    const activeIndex = csgEditor.valuesIndex
                    if (csgEditorValues && csgEditorValues[activeIndex]) {
                        runCSGCode()
                    }

                    alert(`Project loaded successfully from: ${filePath}`)
                } catch (error) {
                    alert(`Failed to load project: ${error.message}`)
                }
                closeModal('load-code-modal')
            }

            window.handleSaveFile = async (event, filePath) => {
                try {
                    let finalPath = filePath;
                    // NEW: Set base path if a new file is being saved for the first time
                    if (!csgEditor.basePath) {
                        const pathSegments = filePath.split('/');
                        pathSegments.pop();
                        csgEditor.basePath = pathSegments.join('/') + '/';
                    }

                    const projectData = {
                        csgCode: csgEditor.values,
                        editorCode: editorCodeEditor.values,
                        meshCache: {}
                    };

                    for (const pageName in meshCache) {
                        const cachedItem = meshCache[pageName]
                        if (cachedItem.updated && cachedItem.mesh) {
                            if (cachedItem.mesh instanceof THREE.Object3D) {
                                projectData.meshCache[pageName] = {
                                    mesh: cachedItem.mesh.toJSON(),
                                    updated: true
                                }
                            } else if (cachedItem.mesh instanceof Brush) {
                                if (
                                    cachedItem.mesh.mesh instanceof
                                    THREE.Object3D
                                ) {
                                    projectData.meshCache[pageName] = {
                                        mesh: {
                                            isBrush: true,
                                            mesh: cachedItem.mesh.mesh.toJSON()
                                        },
                                        updated: true
                                    }
                                }
                            } else if (
                                typeof cachedItem.mesh === 'object' &&
                                cachedItem.mesh !== null
                            ) {
                                const serializedSubmeshes = {}
                                for (const subKey in cachedItem.mesh) {
                                    const item = cachedItem.mesh[subKey]
                                    if (
                                        item &&
                                        item.data instanceof THREE.Object3D
                                    ) {
                                        serializedSubmeshes[subKey] = {
                                            data: item.data.toJSON(),
                                            show: item.show
                                        }
                                    } else if (
                                        item &&
                                        item.data instanceof Brush
                                    ) {
                                        serializedSubmeshes[subKey] = {
                                            data: {
                                                isBrush: true,
                                                mesh: item.data.mesh.toJSON()
                                            },
                                            show: item.show
                                        }
                                    }
                                }
                                projectData.meshCache[pageName] = {
                                    mesh: serializedSubmeshes,
                                    updated: true
                                }
                            }
                        }
                    }

                    const projectDataString = JSON.stringify(
                        projectData,
                        null,
                        2
                    )
                    await api.saveFile(finalPath, projectDataString)
                    alert(`Project saved successfully to: ${finalPath}`)
                } catch (error) {
                    alert(`Failed to save project: ${error.message}`)
                }
                closeModal('save-code-modal')
            }

            window.handleSaveStl = async (event, filePath) => {
                try {
                    let finalPath = filePath
                    if (!finalPath.toLowerCase().endsWith('.stl')) {
                        finalPath += '.stl'
                    }
                    const stlContent = window.stlToSave
                    if (!stlContent) {
                        throw new Error(
                            'No STL content to save. Generate a model first.'
                        )
                    }
                    await api.saveFile(finalPath, stlContent, {
                        'Content-Type': 'text/plain'
                    })
                    alert(`STL file saved successfully to: ${finalPath}`)
                } catch (error) {
                    alert(`Failed to save STL file: ${error.message}`)
                }
                closeModal('save-stl-modal')
            }

            function exportSTL() {
                if (currentObjects.length === 0) {
                    alert('No objects to export!')
                    return
                }
                const exportGroup = new THREE.Group()
                currentObjects.forEach((obj) => {
                    if (obj.isMesh || obj instanceof Brush) {
                        exportGroup.add(obj.clone())
                    }
                })
                window.stlToSave = exporter.parse(exportGroup, {
                    binary: false
                })
                openModal('save-stl-modal')
            }

            // --- New global get() function ---
            function get(name) {
                const requestedIndex = csgEditor.values.findIndex(p => p.title === name);
                if (requestedIndex === -1) {
                    console.error(`Page '${name}' not found.`);
                    return null;
                }

                const requestedPage = csgEditor.values[requestedIndex];
                const requestedPageName = requestedPage.title;

                if (meshCache[requestedPageName] && meshCache[requestedPageName].updated) {
                    console.log(`âœ… Loading cached mesh for page: ${requestedPageName}`);
                    return meshCache[requestedPageName].mesh;
                }

                console.log(`ðŸ” Re-evaluating code for page: ${requestedPageName}`);
                try {
                    const script = new Function(
                        'sphere', 'cube', 'cylinder', 'union', 'difference', 'intersect',
                        'translate', 'rotate', 'scale', 'color', 'floor', 'convexHull',
                        'align', 'line3d', 'linePaths3d', 'get', 'include', 'scaleTo', 'path',
                        requestedPage.content
                    );
                    const result = script(
                        sphere, cube, cylinder, union, difference,
                        intersect, translate, rotate, scale, color,
                        floor, convexHull, align, line3d, linePaths3d, get, include, scaleTo, path
                    );

                    meshCache[requestedPageName] = { mesh: result, updated: true };
                    return result;
                } catch (err) {
                    console.error(`âŒ CSG Error for page '${requestedPageName}':`, err);
                    meshCache[requestedPageName] = { mesh: null, updated: false };
                    alert(`CSG Error for page '${requestedPageName}':\n` + err.message);
                    return null;
                }
            };
            
            // --- New global include() function ---
            const include = (name) => {
                if (codeCache[name] && codeCache[name].updated) {
                    return codeCache[name].result;
                }
            
                const page = editorCodeEditor.values.find(p => p.title === name);
                if (!page) {
                    console.error(`Include error: Page '${name}' not found.`);
                    return null;
                }
            
                console.log(`ðŸ” Compiling included code for page: ${name}`);
                try {
                    const script = new Function(
                        'sphere', 'cube', 'cylinder', 'union', 'difference', 'intersect',
                        'translate', 'rotate', 'scale', 'color', 'floor', 'convexHull',
                        'align', 'line3d', 'linePaths3d', 'get', 'include', 'scaleTo', 'path',
                        page.content
                    );
                    const result = script(
                        sphere, cube, cylinder, union, difference,
                        intersect, translate, rotate, scale, color,
                        floor, convexHull, align, line3d, linePaths3d, get, include, scaleTo, path
                    );
            
                    codeCache[name] = { result: result, updated: true };
                    return result;
                } catch (err) {
                    console.error(`âŒ Include error for page '${name}':`, err);
                    alert(`Include Error for page '${name}':\n` + err.message);
                    return null;
                }
            };
			
			
			// --- New global include() function ---
             window.runEditorScript = () => {
				
				const activeIndex = editorCodeEditor.valuesIndex
                const pageData = editorCodeEditor.values[activeIndex]

                if (!pageData) {
                    console.error('No active page data found in editor.')
                    return
                }

                const pageName = pageData.title;
				if (codeCache[pageName] && codeCache[pageName].updated) {
                    codeCache[pageName].updated =false;
                }
				
				
				include(pageName);
                    
            };

			

            window.runCSGCode = function () {
                currentObjects.forEach((obj) => scene.remove(obj))
                currentObjects = []

                const activeIndex = csgEditor.valuesIndex
                const pageData = csgEditor.values[activeIndex]

                if (!pageData) {
                    console.error('No active page data found in editor.')
                    return
                }

                const pageName = pageData.title
                
                const activeMesh = get(pageName);
                if (activeMesh) {
                    if (
                        activeMesh instanceof THREE.Object3D ||
                        activeMesh instanceof Brush
                    ) {
                        scene.add(activeMesh)
                        currentObjects.push(activeMesh)
                    } else if (
                        typeof activeMesh === 'object' &&
                        activeMesh !== null
                    ) {
                        for (const subKey in activeMesh) {
                            const item = activeMesh[subKey]
                            if (
                                item &&
                                item.data &&
                                (item.data instanceof THREE.Object3D ||
                                    item.data instanceof Brush) &&
                                item.show === true
                            ) {
                                scene.add(item.data)
                                currentObjects.push(item.data)
                            }
                        }
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate)
                controls.update()
                const cameraDirection = new THREE.Vector3()
                camera.getWorldDirection(cameraDirection)
                keyLight.position
                    .copy(camera.position)
                    .add(cameraDirection.multiplyScalar(-10))
                renderer.render(scene, camera)
            }

            window.onload = function () {
                const codePanel = document.getElementById('code-panel')
                const viewPanel = document.getElementById('view-panel')
                const settingsPanel = document.getElementById('settings-panel')
                const editorCodePanel = document.getElementById('editor-code-panel')
                const btn3D = document.getElementById('btn-3d')
                const btnCode = document.getElementById('btn-code')
                const btnEditorCode = document.getElementById('btn-editor-code')
                const btnSettings = document.getElementById('btn-settings')
                const btnLoad = document.getElementById('btn-load')
                const btnSave = document.getElementById('btn-save')
                const widthInput = document.getElementById('width-input')
                const lengthInput = document.getElementById('length-input')
                const gridSizeInput = document.getElementById('grid-size-input')
                const libraryPathInput = document.getElementById('library-path-input');
                const saveSettingsBtn =
                    document.getElementById('save-settings-btn')
                const loadCodeModal = document.getElementById('load-code-modal')
                const saveCodeModal = document.getElementById('save-code-modal')
                const saveStlModal = document.getElementById('save-stl-modal')
                const clearCacheBtn = document.getElementById('clear-cache-btn')

                csgEditor = document.getElementById('csg-code')
                editorCodeEditor = document.getElementById('editor-code')
                settings = {
                    plateWidth: 220,
                    plateLength: 220,
                    gridSize: 10,
                    libraryPath: '/csgLib'
                }
                currentObjects = []

                window.addEventListener('resize', resizeRenderer)
                resizeRenderer()
                animate()

                btn3D.addEventListener('click', () => showView('3d'))
                btnCode.addEventListener('click', () => showView('code'))
                btnEditorCode.addEventListener('click', () => showView('editor-code'))
                btnSettings.addEventListener('click', () =>
                    showView('settings')
                )
                btnLoad.addEventListener('click', () =>
                    openModal('load-code-modal')
                )

                btnSave.addEventListener('click', () => {
                    const codePanel = document.getElementById('code-panel');
                    const editorCodePanel = document.getElementById('editor-code-panel');
                    const viewPanel = document.getElementById('view-panel');
                    const settingsPanel = document.getElementById('settings-panel');

                    if (codePanel.style.display === 'block' || editorCodePanel.style.display === 'block') {
                        openModal('save-code-modal');
                    } else if (viewPanel.style.display === 'block') {
                        exportSTL();
                    } else if (settingsPanel.style.display === 'block') {
                        saveSettings();
                    }
                });

                function saveSettings() {
                    const newWidth = parseFloat(widthInput.value)
                    const newLength = parseFloat(lengthInput.value)
                    const newGridSize = parseFloat(gridSizeInput.value)
                    const newLibraryPath = libraryPathInput.value;

                    if (
                        isNaN(newWidth) ||
                        newWidth <= 0 ||
                        isNaN(newLength) ||
                        newLength <= 0 ||
                        isNaN(newGridSize) ||
                        newGridSize <= 0
                    ) {
                        alert(
                            'Please enter valid positive numbers for all settings.'
                        )
                        return
                    }

                    settings.plateWidth = newWidth
                    settings.plateLength = newLength
                    settings.gridSize = newGridSize
                    settings.libraryPath = newLibraryPath;

                    localStorage.setItem(
                        'csg-editor-settings',
                        JSON.stringify(settings)
                    )

                    createBuildPlate()
                    alert('Settings saved successfully!')
                }

                saveSettingsBtn.addEventListener('click', saveSettings);
                
                // New function to clear caches but keep local storage
                function clearAllCache() {
                    // Clear in-memory caches
                    for (const key in meshCache) {
                        if (meshCache.hasOwnProperty(key)) {
                            delete meshCache[key];
                        }
                    }
                    for (const key in codeCache) {
                        if (codeCache.hasOwnProperty(key)) {
                            delete codeCache[key];
                        }
                    }
                    
                    // Remove all objects from the scene to visually show the cache is clear
                    currentObjects.forEach(obj => scene.remove(obj));
                    currentObjects = [];

                    alert('In-memory cache has been cleared. The model has been removed from the scene. Click "Run" to re-render.');
                }

                clearCacheBtn.addEventListener('click', clearAllCache);

                editorCodeEditor.addEventListener('keydown', function (e) {
                    const pageIndex = editorCodeEditor.valuesIndex;
                    const pageData = editorCodeEditor.values[pageIndex];
                    if (pageData && pageData.title) {
                        const pageName = pageData.title;
                        if (codeCache[pageName]) {
                            codeCache[pageName].updated = false;
                            const csgPageIndex = csgEditor.valuesIndex;
                            const csgPageData = csgEditor.values[csgPageIndex];
                            if (csgPageData && csgPageData.title) {
                                if (meshCache[csgPageData.title]) {
                                    meshCache[csgPageData.title].updated = false;
                                }
                            }
                        }
                    }
                });

                csgEditor.addEventListener('keydown', function (e) {
                    const pageIndex = csgEditor.valuesIndex;
                    const pageData = csgEditor.values[pageIndex]

                    if (pageData && pageData.title) {
                        const pageName = pageData.title
                        if (meshCache[pageName]) {
                            meshCache[pageName].updated = false
                        }
                    }
                })

                window.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault()
                        const codePanel = document.getElementById('code-panel');
                        const editorCodePanel = document.getElementById('editor-code-panel');
                        const viewPanel = document.getElementById('view-panel');
                        if (codePanel.style.display === 'block' || editorCodePanel.style.display === 'block') {
                            openModal('save-code-modal');
                        } else if (viewPanel.style.display === 'block') {
                            exportSTL();
                        }
                    }
                })

                showView('3d')

                const savedSettings = localStorage.getItem(
                    'csg-editor-settings'
                )
                if (savedSettings) {
                    settings = JSON.parse(savedSettings)
                }
                widthInput.value = settings.plateWidth
                lengthInput.value = settings.plateLength
                gridSizeInput.value = settings.gridSize
                libraryPathInput.value = settings.libraryPath;
                createBuildPlate()

                const savedCsgCode = localStorage.getItem('csg-editor-code')
                if (savedCsgCode) {
                    try {
                        const loadedValues = JSON.parse(savedCsgCode)
                        csgEditor.values = loadedValues
                        csgEditor.setAttribute('active', '0')
                    } catch (e) {
                        csgEditor.value = savedCsgCode
                        for (const key in meshCache) {
                            delete meshCache[key]
                        }
                    }
                }
                
                const savedEditorCode = localStorage.getItem('csg-editor-functions')
                if (savedEditorCode) {
                    try {
                        const loadedValues = JSON.parse(savedEditorCode)
                        editorCodeEditor.values = loadedValues
                        editorCodeEditor.setAttribute('active', '0')
                    } catch (e) {
                        editorCodeEditor.value = savedEditorCode;
                        for (const key in codeCache) {
                            delete codeCache[key];
                        }
                    }
                }

                runCSGCode();
            }
        </script>
    </body>
</html>


