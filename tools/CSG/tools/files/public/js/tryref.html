// Function to convert a Float32Array to a Base64 string
function floatArrayToBase64(floatArray) {
    // Create a Uint8Array from the Float32Array
    const uint8Array = new Uint8Array(floatArray.buffer);
    let binaryString = '';
    for (let i = 0; i < uint8Array.length; i++) {
        binaryString += String.fromCharCode(uint8Array[i]);
    }
    return btoa(binaryString); // Use the built-in btoa() function
}

// Function to convert a Base64 string back to a Float32Array
function base64ToFloatArray(base64String) {
    const binaryString = atob(base64String);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return new Float32Array(bytes.buffer);
}

const cloneAndStripMesh = (mesh) => {
    if (mesh instanceof THREE.Mesh) {
        // ...
        return {
            $jsonMesh: {
                mesh: {
                    // Embed a custom attribute to indicate Base64 encoding
                    attributes: {
                        position: {
                            array: floatArrayToBase64(mesh.geometry.attributes.position.array),
                            itemSize: 3
                        },
                        normal: {
                            array: floatArrayToBase64(mesh.geometry.attributes.normal.array),
                            itemSize: 3
                        }
                    }
                }
            }
        };
    }
    // ... handle Brush objects similarly ...
};

const handleSaveFile = async (event, filePath) => {
    // ...
    const projectData = {
        csgCode: csgEditor.values,
        editorCode: editorCodeEditor.values,
        // The cloneFilter will now save Base64 strings
        meshCache: cloneFilter(project.meshCache, isMesh, cloneAndStripMesh)
    };
    // ...
};

// You'd also need a corresponding function to load the Base64 data
// from the JSON and convert it back into a Float32Array for the geometry.
