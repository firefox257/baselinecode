


<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>CSG Editor - Mobile</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                overflow: hidden;
                font-family: 'Segoe UI', sans-serif;
                background: #1e1e1e;
                color: white;
            }

            #toolbar {
                display: flex;
                background: #2c3e50;
                color: white;
                padding: 0;
                gap: 0;
                justify-content: center;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                z-index: 10;
                position: relative;
            }

            #toolbar button {
                background: #3498db;
                color: white;
                border: none;
                font-size: 1em;
                width: 35px;
                height: 35px;
                cursor: pointer;
                transition: background 0.2s, transform 0.1s;
                box-shadow: none;
                border-radius: 0;
            }

            #toolbar button:active {
                transform: scale(0.95);
            }

            #toolbar button:hover {
                background: #2980b9;
            }

            .toolbar-separator {
                width: 1px;
                background-color: #446688;
                height: 35px;
            }

            #main-container {
                width: 100%;
                height: calc(100vh - 35px);
                position: relative;
            }

            #code-panel,
            #view-panel,
            #settings-panel {
                position: absolute;
                width: 100%;
                height: 100%;
                display: none;
                background: white;
            }

            #code-panel {
                background: #1e1e1e;
                color: #f8f8f8;
            }

            #settings-panel {
                background: #282c34;
                color: #f8f8f8;
                padding: 20px;
                box-sizing: border-box;
                overflow-y: auto;
            }

            #settings-panel h2 {
                color: #61afef;
                border-bottom: 2px solid #545862;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }

            #settings-panel label {
                font-size: 1em;
                color: #a0a0a0;
                margin-bottom: 5px;
            }

            #settings-panel input[type='number'] {
                width: 80px;
                padding: 5px;
                background: #3e4451;
                border: 1px solid #545862;
                color: #f8f8f8;
                border-radius: 4px;
                margin-left: 10px;
            }

            #save-settings-btn {
                background: #28a745;
                color: white;
                border: none;
                padding: 10px 15px;
                border-radius: 5px;
                cursor: pointer;
                margin-top: 20px;
            }

            #save-settings-btn:hover {
                background: #218838;
            }

            #three-canvas {
                width: 100%;
                height: 100%;
                display: block;
            }

            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: none;
                justify-content: center;
                align-items: center;
                z-index: 10000;
            }

            .modal-content {
                background: #282c34;
                width: 100%;
                height: 100%;
                max-width: 100%;
                max-height: 100%;
            }
        </style>

        <script type="importmap">
            {
                "imports": {
                    "three": "./build/three.module.js",
                    "three/addons/": "./jsm/",
                    "three-mesh-bvh": "./js/mesh-bvh.js",
                    "three-bvh-csg": "./js/csg-bvh.js"
                }
            }
        </script>
    </head>
    <body>
        <div id="toolbar">
            <button id="btn-3d" title="3D View">&#x1F5BC;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-code" title="Code Editor">&#x1F4BB;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-settings" title="Settings">&#x2699;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-load" title="Load Project">&#x1F4E5;</button>
            <div class="toolbar-separator"></div>
            <button id="btn-save" title="Run Code">&#x1F4BE;</button>
        </div>

        <div id="main-container">
            <div id="code-panel">
                <textcode
                    id="csg-code"
                    title="CSG Script"
                    onrun="runCSGCode();">
                    // Edit and save to update!
/*
return floor(
	difference(
		color(0x0000ffff,sphere({ r: 20, fn:100 })),
		translate([15, 0, 0], cube([20, 20, 20])),
		translate([0, 0, 15], cylinder({ r: 20, h: 30 , fn:100}))
	)
);
*/
//return cube([40, 50, 60]);
/*
var b1= floor(
	translate([30,0,0],
		cylinder({d:10, h:20, fn:50})
	)
);

var b2= floor(
	translate([0,0,0],
		cube([10,10,10])
	)
);

return {
	b1:{
	data:b1,
	show:true
	},
	b2:{
		data:b2,
		show:true
		}
	};
	*/
	
	return translate([30,0,0],
	union(
	
	translate([5,5,0],
		color(0xffff0000, cube([10,10,10]))
	),
	translate([0,0,0],
		cube([10,10,10])
	)
	
	)
	);
	
	
                </textcode>
            </div>

            <div id="view-panel">
                <canvas id="three-canvas"></canvas>
            </div>

            <div id="settings-panel">
                <h2>Settings</h2>
                <label for="width-input">Grid Width:</label>
                <input type="number" id="width-input" value="220" />
                mm<br /><br />
                <label for="length-input">Grid Length:</label>
                <input type="number" id="length-input" value="220" />
                mm<br /><br />
                <label for="grid-size-input">Grid Spacing:</label>
                <input type="number" id="grid-size-input" value="10" />
                mm<br /><br />
                <button id="save-settings-btn">Save Settings</button>
            </div>
        </div>

        <div id="load-code-modal" class="modal-overlay">
            <div class="modal-content">
                <filepicker
                    id="load-picker"
                    useFileButtonText="Load Code"
                    onfilepick="handleLoadFile(event, filePath, 'csg-code')"
                    oncancel="closeModal('load-code-modal')">
                </filepicker>
            </div>
        </div>

        <div id="save-code-modal" class="modal-overlay">
            <div class="modal-content">
                <filepicker
                    id="save-picker"
                    useFileButtonText="Save Code"
                    onfilepick="handleSaveFile(event, filePath, 'csg-code')"
                    oncancel="closeModal('save-code-modal')">
                </filepicker>
            </div>
        </div>

        <div id="save-stl-modal" class="modal-overlay">
            <div class="modal-content">
                <er
                    id="save-stl-picker"
                    useFileButtonText="Save STL"
                    onfilepick="handleSaveStl(event, filePath)"
                    oncancel="closeModal('save-stl-modal')">
                </filepicker>
            </div>
        </div>

        <script type="module" src="/ux/textCode.js"></script>
        <script type="module" src="/ux/filePicker.js"></script>

        <script type="module">
            import * as THREE from 'three'
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
            import { STLExporter } from 'three/addons/exporters/STLExporter.js'
            import * as SCAD from './js/scadCSG.js'
            import { Brush } from 'three-bvh-csg'
            import { api } from '/js/apiCalls.js'

            // Declare global variables
            let settings
            let currentObjects
            const meshCache = {}
            const exporter = new STLExporter()
            let editor
			
            // --- Three.js Setup ---
            const canvas = document.getElementById('three-canvas')
            const renderer = new THREE.WebGLRenderer({
                canvas,
                antialias: true
            })
            renderer.setClearColor(0x1e1e1e)

            const scene = new THREE.Scene()
            const camera = new THREE.PerspectiveCamera(
                60,
                window.innerWidth / window.innerHeight,
                0.01,
                2000
            )

            camera.position.set(0, 50, 50)
            camera.lookAt(0, 0, 0)

            const controls = new OrbitControls(camera, canvas)
            controls.enableDamping = true
            controls.dampingFactor = 0.1

            // --- 3-Point Lighting ---
            const keyLight = new THREE.PointLight(0xffffff, 7, 1000, 0.2)
            const ambientLight = new THREE.AmbientLight(0xffcc66, 0.5)
            scene.add(keyLight, ambientLight)

            // --- Vertical Line at Origin (Y-axis) ---
            const originLineMaterial = new THREE.LineBasicMaterial({
                color: 0x555555
            })
            const originLineGeometry = new THREE.BufferGeometry().setFromPoints(
                [new THREE.Vector3(0, -100, 0), new THREE.Vector3(0, 500, 0)]
            )
            const originLine = new THREE.LineSegments(
                originLineGeometry,
                originLineMaterial
            )
            scene.add(originLine)

            // --- Flat Grid & Bounding Box ---
            let buildPlateGrid = null
            let buildPlateBox = null

            function createBuildPlate() {
                if (buildPlateGrid) {
                    scene.remove(buildPlateGrid)
                    buildPlateGrid.geometry.dispose()
                    buildPlateGrid = null
                }
                if (buildPlateBox) {
                    scene.remove(buildPlateBox)
                    buildPlateBox.geometry.dispose()
                    buildPlateBox = null
                }

                const plateSize = Math.max(
                    settings.plateWidth,
                    settings.plateLength
                )
                const divisions = Math.floor(plateSize / settings.gridSize)
                buildPlateGrid = new THREE.GridHelper(
                    plateSize,
                    divisions,
                    0x555555,
                    0x555555
                )
                buildPlateGrid.position.y = 0
                scene.add(buildPlateGrid)

                const boxMaterial = new THREE.LineBasicMaterial({
                    color: 0xcccccc
                })
                const boxGeometry = new THREE.BufferGeometry()
                const halfWidth = settings.plateWidth / 2
                const halfLength = settings.plateLength / 2
                const boxVertices = new Float32Array([
                    -halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    -halfLength,
                    halfWidth,
                    0,
                    halfLength,
                    halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    halfLength,
                    -halfWidth,
                    0,
                    -halfLength
                ])
                boxGeometry.setAttribute(
                    'position',
                    new THREE.BufferAttribute(boxVertices, 3)
                )
                buildPlateBox = new THREE.LineSegments(boxGeometry, boxMaterial)
                scene.add(buildPlateBox)
            }

            function resizeRenderer() {
                const width = window.innerWidth
                const height = window.innerHeight - 35
                renderer.setSize(width, height)
                camera.aspect = width / height
                camera.updateProjectionMatrix()
            }

            // --- View Management ---
            function showView(id) {
                const codePanel = document.getElementById('code-panel')
                const viewPanel = document.getElementById('view-panel')
                const settingsPanel = document.getElementById('settings-panel')
                const btn3D = document.getElementById('btn-3d')
                const btnCode = document.getElementById('btn-code')
                const btnSettings = document.getElementById('btn-settings')
                const btnLoad = document.getElementById('btn-load')
                const btnSave = document.getElementById('btn-save')

                codePanel.style.display = 'none'
                viewPanel.style.display = 'none'
                settingsPanel.style.display = 'none'
                btn3D.style.backgroundColor = '#3498db'
                btnCode.style.backgroundColor = '#3498db'
                btnSettings.style.backgroundColor = '#3498db'
                btnLoad.style.backgroundColor = '#3498db'
                btnSave.style.backgroundColor = '#3498db'
                if (id === '3d') {
                    viewPanel.style.display = 'block'
                    btn3D.style.backgroundColor = '#e74c3c'
                } else if (id === 'code') {
                    codePanel.style.display = 'block'
                    btnCode.style.backgroundColor = '#e74c3c'
                } else if (id === 'settings') {
                    settingsPanel.style.display = 'block'
                    btnSettings.style.backgroundColor = '#e74c3c'
                }
            }
			
            // --- Modal Functions ---
            window.openModal = (id) => {
                document.getElementById(id).style.display = 'flex'
            }

            window.closeModal = (id) => {
                document.getElementById(id).style.display = 'none'
            }

            // --- Three.js loaders for handling JSON parsing ---
            window.handleLoadFile = async (event, filePath) => {
				//console.log("loading");
                try {
                    const fileContent = await api.readFile(filePath)
                    const projectData = JSON.parse(fileContent)

                    // Load text code values
					
                    editor.values = projectData.code
                    editor.setAttribute('active', '0')
					

                    // Load and rehydrate cached meshes
                    const objectLoader = new THREE.ObjectLoader()
                    if (projectData.cache) {
                        for (const pageName in projectData.cache) {
                            const cachedData = projectData.cache[pageName]
                            let rehydratedMesh = null

                            if (cachedData.mesh) {
                                // Check if it's a single Brush object
                                if (cachedData.mesh.isBrush) {
                                    const mesh = objectLoader.parse(
                                        cachedData.mesh.mesh
                                    )
                                    rehydratedMesh = new Brush(mesh)
                                }
                                // Check if it's a single Three.js object (e.g., a Mesh)
                                else if (
                                    cachedData.mesh.geometries ||
                                    cachedData.mesh.object
                                ) {
                                    rehydratedMesh = objectLoader.parse(
                                        cachedData.mesh
                                    )
                                }
                                // Check if it's an object containing sub-meshes (like your b1, b2 example)
                                else if (
                                    typeof cachedData.mesh === 'object' &&
                                    cachedData.mesh !== null
                                ) {
                                    const rehydratedSubmeshes = {}
                                    for (const subKey in cachedData.mesh) {
                                        const item = cachedData.mesh[subKey]
                                        if (item && item.data) {
                                            let subMesh = null
                                            if (item.data.isBrush) {
                                                const mesh = objectLoader.parse(
                                                    item.data.mesh
                                                )
                                                subMesh = new Brush(mesh)
                                            } else {
                                                subMesh = objectLoader.parse(
                                                    item.data
                                                )
                                            }
                                            rehydratedSubmeshes[subKey] = {
                                                data: subMesh,
                                                show: item.show
                                            }
                                        }
                                    }
                                    rehydratedMesh = rehydratedSubmeshes
                                }
                            }

                            // Populate the global meshCache
                            meshCache[pageName] = {
                                mesh: rehydratedMesh,
                                updated: true
                            }
                        }
                    }

                    // Run the code to display the currently active page (from cache)
                    const editorValues = editor.values
                    const activeIndex = editor.valuesIndex
                    if (editorValues && editorValues[activeIndex]) {
                        runCSGCode()
                    }

                    alert(`Project loaded successfully from: ${filePath}`)
                } catch (error) {
                    alert(`Failed to load project: ${error.message}`)
                }
                closeModal('load-code-modal')
            }

            window.handleSaveFile = async (event, filePath) => {
                try {
                    const codeContent = editor.values
                    const projectData = {
                        code: codeContent,
                        cache: {}
                    }

                    // Serialize the mesh cache
                    for (const pageName in meshCache) {
                        const cachedItem = meshCache[pageName]
                        if (cachedItem.updated && cachedItem.mesh) {
                            // Check if mesh is a valid Three.js object before trying to serialize
                            if (cachedItem.mesh instanceof THREE.Object3D) {
                                projectData.cache[pageName] = {
                                    mesh: cachedItem.mesh.toJSON(),
                                    updated: true
                                }
                            } else if (cachedItem.mesh instanceof Brush) {
                                // Special handling for Brush to save its internal mesh component
                                if (
                                    cachedItem.mesh.mesh instanceof
                                    THREE.Object3D
                                ) {
                                    projectData.cache[pageName] = {
                                        mesh: {
                                            isBrush: true,
                                            mesh: cachedItem.mesh.mesh.toJSON()
                                        },
                                        updated: true
                                    }
                                }
                            } else if (
                                typeof cachedItem.mesh === 'object' &&
                                cachedItem.mesh !== null
                            ) {
                                // Handle objects with sub-meshes (e.g., return {b1, b2})
                                const serializedSubmeshes = {}
                                for (const subKey in cachedItem.mesh) {
                                    const item = cachedItem.mesh[subKey]
                                    if (
                                        item &&
                                        item.data instanceof THREE.Object3D
                                    ) {
                                        serializedSubmeshes[subKey] = {
                                            data: item.data.toJSON(),
                                            show: item.show
                                        }
                                    } else if (
                                        item &&
                                        item.data instanceof Brush
                                    ) {
                                        serializedSubmeshes[subKey] = {
                                            data: {
                                                isBrush: true,
                                                mesh: item.data.mesh.toJSON()
                                            },
                                            show: item.show
                                        }
                                    }
                                }
                                projectData.cache[pageName] = {
                                    mesh: serializedSubmeshes,
                                    updated: true
                                }
                            }
                        }
                    }

                    const projectDataString = JSON.stringify(
                        projectData,
                        null,
                        2
                    )
                    await api.saveFile(filePath, projectDataString)
                    alert(`Project saved successfully to: ${filePath}`)
                } catch (error) {
                    alert(`Failed to save project: ${error.message}`)
                }
                closeModal('save-code-modal')
            }

            window.handleSaveStl = async (event, filePath) => {
                try {
                    let finalPath = filePath
                    if (!finalPath.toLowerCase().endsWith('.stl')) {
                        finalPath += '.stl'
                    }
                    const stlContent = window.stlToSave
                    if (!stlContent) {
                        throw new Error(
                            'No STL content to save. Generate a model first.'
                        )
                    }
                    await api.saveFile(finalPath, stlContent, {
                        'Content-Type': 'text/plain'
                    })
                    alert(`STL file saved successfully to: ${finalPath}`)
                } catch (error) {
                    alert(`Failed to save STL file: ${error.message}`)
                }
                closeModal('save-stl-modal')
            }

            function exportSTL() {
                if (currentObjects.length === 0) {
                    alert('No objects to export!')
                    return
                }
                const exportGroup = new THREE.Group()
                currentObjects.forEach((obj) => {
                    if (obj.isMesh || obj instanceof Brush) {
                        exportGroup.add(obj.clone())
                    }
                })
                window.stlToSave = exporter.parse(exportGroup, {
                    binary: false
                })
                openModal('save-stl-modal')
            }

            // --- CSG Execution with Caching ---
            window.runCSGCode = function () {
                // Clear the existing objects from the scene
                currentObjects.forEach((obj) => scene.remove(obj))
                currentObjects = []

                // Get the active page name and code directly from the global editor
                const activeIndex = editor.valuesIndex
                const pageData = editor.values[activeIndex]

                // Add a check to ensure pageData is valid
                if (!pageData) {
                    console.error('No active page data found in editor.')
                    return
                }

                const pageName = pageData.title
                const textCode = pageData.content

                // Define the 'get' function here so it has access to the cache and editor
                const get = (name) => {
                    // Find the index and code for the requested page name
                    const requestedIndex = editor.values.findIndex(p => p.title === name);
                    if (requestedIndex === -1) {
                        console.error(`Page '${name}' not found.`);
                        return null;
                    }

                    const requestedPage = editor.values[requestedIndex];
                    const requestedPageName = requestedPage.title;

                    // Check if the requested mesh is already in the cache and is up-to-date
                    if (meshCache[requestedPageName] && meshCache[requestedPageName].updated) {
                        console.log(`✅ Loading cached mesh for page: ${requestedPageName}`);
                        return meshCache[requestedPageName].mesh;
                    }

                    console.log(`🔍 Re-evaluating code for page: ${requestedPageName}`);
                    try {
                        // Recursively execute the code for the requested page
                        const script = new Function(
                            'sphere', 'cube', 'cylinder', 'union', 'difference', 'intersect',
                            'translate', 'rotate', 'scale', 'color', 'floor', 'convexHull',
                            'align', 'line3d', 'linePaths3d', 'get',
                            requestedPage.content
                        );
                        const result = script(
                            SCAD.sphere, SCAD.cube, SCAD.cylinder, SCAD.union, SCAD.difference,
                            SCAD.intersect, SCAD.translate, SCAD.rotate, SCAD.scale, SCAD.color,
                            SCAD.floor, SCAD.convexHull, SCAD.align, SCAD.line3d, SCAD.linePaths3d, get
                        );

                        // Cache the newly generated mesh and mark it as updated
                        meshCache[requestedPageName] = { mesh: result, updated: true };
                        return result;
                    } catch (err) {
                        console.error(`❌ CSG Error for page '${requestedPageName}':`, err);
                        meshCache[requestedPageName] = { mesh: null, updated: false };
                        alert(`CSG Error for page '${requestedPageName}':\n` + err.message);
                        return null;
                    }
                };
                
                // Now, ONLY show the mesh for the currently active page.
                const activeMesh = get(pageName);
                if (activeMesh) {
                    if (
                        activeMesh instanceof THREE.Object3D ||
                        activeMesh instanceof Brush
                    ) {
                        scene.add(activeMesh)
                        currentObjects.push(activeMesh)
                    } else if (
                        typeof activeMesh === 'object' &&
                        activeMesh !== null
                    ) {
                        for (const subKey in activeMesh) {
                            const item = activeMesh[subKey]
                            if (
                                item &&
                                item.data &&
                                (item.data instanceof THREE.Object3D ||
                                    item.data instanceof Brush) &&
                                item.show === true
                            ) {
                                scene.add(item.data)
                                currentObjects.push(item.data)
                            }
                        }
                    }
                }
            }

            // Animation Loop
            function animate() {
                requestAnimationFrame(animate)
                controls.update()
                const cameraDirection = new THREE.Vector3()
                camera.getWorldDirection(cameraDirection)
                keyLight.position
                    .copy(camera.position)
                    .add(cameraDirection.multiplyScalar(-10))
                renderer.render(scene, camera)
            }

            window.onload = function () {
                const codePanel = document.getElementById('code-panel')
                const viewPanel = document.getElementById('view-panel')
                const settingsPanel = document.getElementById('settings-panel')
                const btn3D = document.getElementById('btn-3d')
                const btnCode = document.getElementById('btn-code')
                const btnLoad = document.getElementById('btn-load')
                const btnSave = document.getElementById('btn-save')
                const btnSettings = document.getElementById('btn-settings')
                const widthInput = document.getElementById('width-input')
                const lengthInput = document.getElementById('length-input')
                const gridSizeInput = document.getElementById('grid-size-input')
                const saveSettingsBtn =
                    document.getElementById('save-settings-btn')
                const loadCodeModal = document.getElementById('load-code-modal')
                const saveCodeModal = document.getElementById('save-code-modal')
                const saveStlModal = document.getElementById('save-stl-modal')

                editor = document.getElementById('csg-code')
                settings = {
                    plateWidth: 220,
                    plateLength: 220,
                    gridSize: 10
                }
                currentObjects = []

                window.addEventListener('resize', resizeRenderer)
                resizeRenderer()
                animate()

                btn3D.addEventListener('click', () => showView('3d'))
                btnCode.addEventListener('click', () => showView('code'))
                btnSettings.addEventListener('click', () =>
                    showView('settings')
                )
                btnLoad.addEventListener('click', () =>
                    openModal('load-code-modal')
                )

                btnSave.addEventListener('click', () => {
                    if (codePanel.style.display === 'block') {
                        openModal('save-code-modal')
                    } else {
                        exportSTL()
                    }
                })

                saveSettingsBtn.addEventListener('click', () => {
                    const newWidth = parseFloat(widthInput.value)
                    const newLength = parseFloat(lengthInput.value)
                    const newGridSize = parseFloat(gridSizeInput.value)

                    if (
                        isNaN(newWidth) ||
                        newWidth <= 0 ||
                        isNaN(newLength) ||
                        newLength <= 0 ||
                        isNaN(newGridSize) ||
                        newGridSize <= 0
                    ) {
                        alert(
                            'Please enter valid positive numbers for all settings.'
                        )
                        return
                    }

                    settings.plateWidth = newWidth
                    settings.plateLength = newLength
                    settings.gridSize = newGridSize

                    localStorage.setItem(
                        'csg-editor-settings',
                        JSON.stringify(settings)
                    )

                    createBuildPlate()
                    alert('Settings saved successfully!')
                })

                editor.addEventListener('keydown', function (e) {
                    //console.log("onchange"); 
					const pageIndex = editor.valuesIndex;
                    const pageData = editor.values[pageIndex]

                    if (pageData && pageData.title) {
                        const pageName = pageData.title
                        if (meshCache[pageName]) {
                            meshCache[pageName].updated = false
                        }
                    }
                })

                window.addEventListener('keydown', (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault()
                        if (codePanel.style.display === 'block') {
                            openModal('save-code-modal')
                        } else if (viewPanel.style.display === 'block') {
                            exportSTL()
                        }
                    }
                })

                showView('3d')

                const savedSettings = localStorage.getItem(
                    'csg-editor-settings'
                )
                if (savedSettings) {
                    settings = JSON.parse(savedSettings)
                }
                widthInput.value = settings.plateWidth
                lengthInput.value = settings.plateLength
                gridSizeInput.value = settings.gridSize
                createBuildPlate()

                const savedCode = localStorage.getItem('csg-editor-code')
                if (savedCode) {
                    try {
                        const loadedValues = JSON.parse(savedCode)
                        editor.values = loadedValues
                        editor.setAttribute('active', '0')
                    } catch (e) {
                        editor.value = savedCode
                        for (const key in meshCache) {
                            delete meshCache[key]
                        }
                    }
                }

                runCSGCode();
            }
        </script>
    </body>
</html>

