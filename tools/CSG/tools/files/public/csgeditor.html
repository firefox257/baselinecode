



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>CSG Editor - Mobile</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Segoe UI', sans-serif;
      background: #1e1e1e;
      color: white;
    }

    #toolbar {
      display: flex;
      background: #2c3e50;
      color: white;
      padding: 0;
      gap: 0;
      justify-content: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      z-index: 10;
      position: relative;
    }

    #toolbar button {
      background: #3498db;
      color: white;
      border: none;
      font-size: 1em;
      width: 35px;
      height: 35px;
      cursor: pointer;
      transition: background 0.2s, transform 0.1s;
      box-shadow: none;
      border-radius: 0;
    }

    #toolbar button:active {
      transform: scale(0.95);
    }

    #toolbar button:hover {
      background: #2980b9;
    }
    
    .toolbar-separator {
      width: 1px;
      background-color: #446688;
      height: 35px;
    }

    #main-container {
      width: 100%;
      height: calc(100vh - 35px);
      position: relative;
    }

    #code-panel, #view-panel, #settings-panel {
      position: absolute;
      width: 100%;
      height: 100%;
      display: none;
      background: white;
    }

    #code-panel {
      background: #1e1e1e;
      color: #f8f8f8;
    }
    
    #settings-panel {
        background: #282c34;
        color: #f8f8f8;
        padding: 20px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    #settings-panel h2 {
        color: #61afef;
        border-bottom: 2px solid #545862;
        padding-bottom: 10px;
        margin-bottom: 20px;
    }

    #settings-panel label {
        font-size: 1em;
        color: #a0a0a0;
        margin-bottom: 5px;
    }

    #settings-panel input[type="number"] {
        width: 80px;
        padding: 5px;
        background: #3e4451;
        border: 1px solid #545862;
        color: #f8f8f8;
        border-radius: 4px;
        margin-left: 10px;
    }

    #save-settings-btn {
        background: #28a745;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        margin-top: 20px;
    }

    #save-settings-btn:hover {
        background: #218838;
    }

    #three-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/",
        "three-mesh-bvh": "https://cdn.jsdelivr.net/npm/three-mesh-bvh@0.9.1/build/index.module.js",
        "three-bvh-csg": "https://cdn.jsdelivr.net/npm/three-bvh-csg@0.0.17/build/index.module.js"
      }
    }
  </script>
</head>
<body>

  <div id="toolbar">
    <button id="btn-3d" title="3D View">&#x1F5BC;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-code" title="Code Editor">&#x1F4BB;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-settings" title="Settings">&#x2699;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-load" title="Load Project">&#x1F4E5;</button>
    <div class="toolbar-separator"></div>
    <button id="btn-save" title="Run Code">&#x1F4BE;</button>
  </div>

  <div id="main-container">
    <div id="code-panel">
      <textcode id="csg-code" title="CSG Script" onsave="runCSGCode(this);">
// Edit and save to update!
/*
return floor(
	difference(
		color(0x0000ffff,sphere({ r: 20, fn:100 })),
		translate([15, 0, 0], cube([20, 20, 20])),
		translate([0, 0, 15], cylinder({ r: 20, h: 30 , fn:100}))
	)
);
*/
return cube([40, 50, 60]);
      </textcode>
    </div>

    <div id="view-panel">
      <canvas id="three-canvas"></canvas>
    </div>
    
    <div id="settings-panel">
        <h2>Settings</h2>
        <label for="width-input">Grid Width:</label>
        <input type="number" id="width-input" value="220" /> mm<br><br>
        <label for="length-input">Grid Length:</label>
        <input type="number" id="length-input" value="220" /> mm<br><br>
        <label for="grid-size-input">Grid Spacing:</label>
        <input type="number" id="grid-size-input" value="10" /> mm<br><br>
        <button id="save-settings-btn">Save Settings</button>
    </div>
  </div>

  <script type="module" src="/ux/textCode.js"></script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { Brush, Evaluator, ADDITION, SUBTRACTION, INTERSECTION } from 'three-bvh-csg';
    import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';
    import { createfilePicker } from '/ux/filePicker.js';
    import { api } from '/js/apiCalls.js';
    import { STLExporter } from 'three/addons/exporters/STLExporter.js';
    
    // --- Default & Stored Settings ---
    const DEFAULT_SETTINGS = {
        plateWidth: 220,
        plateLength: 220,
        gridSize: 10
    };
    let settings = { ...DEFAULT_SETTINGS };

    // --- DOM Elements ---
    const codePanel = document.getElementById('code-panel');
    const viewPanel = document.getElementById('view-panel');
    const btn3D = document.getElementById('btn-3d');
    const btnCode = document.getElementById('btn-code');
    const btnLoad = document.getElementById('btn-load');
    const btnSave = document.getElementById('btn-save');
    const btnSettings = document.getElementById('btn-settings');
    const settingsPanel = document.getElementById('settings-panel');
    const widthInput = document.getElementById('width-input');
    const lengthInput = document.getElementById('length-input');
    const gridSizeInput = document.getElementById('grid-size-input');
    const saveSettingsBtn = document.getElementById('save-settings-btn');

    // --- Three.js Setup ---
    const canvas = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x1e1e1e);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 2000);
    camera.position.set(0, 50, 50);
    camera.lookAt(0, 0, 0);
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    // --- 3-Point Lighting ---
    const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
    const fillLight = new THREE.DirectionalLight(0xffffff, 0.7);
    const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
    const ambient = new THREE.AmbientLight(0x404040, 1.2);
    scene.add(keyLight, fillLight, backLight, ambient);
    
    // --- Vertical Line at Origin (Y-axis) ---
    const originLineMaterial = new THREE.LineBasicMaterial({ color: 0x555555 });
    const originLineGeometry = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(0, -100, 0),
      new THREE.Vector3(0, 100, 0)
    ]);
    const originLine = new THREE.LineSegments(originLineGeometry, originLineMaterial);
    scene.add(originLine);

    // --- Flat Grid & Bounding Box ---
    let buildPlateGrid = null;
    let buildPlateBox = null;

    function createBuildPlate() {
        if (buildPlateGrid) {
            scene.remove(buildPlateGrid);
            buildPlateGrid.geometry.dispose();
            buildPlateGrid = null;
        }
        if (buildPlateBox) {
            scene.remove(buildPlateBox);
            buildPlateBox.geometry.dispose();
            buildPlateBox = null;
        }

        const plateSize = Math.max(settings.plateWidth, settings.plateLength);
        const divisions = Math.floor(plateSize / settings.gridSize);
        buildPlateGrid = new THREE.GridHelper(
            plateSize,
            divisions,
            0x555555,
            0x555555
        );
        buildPlateGrid.position.y = 0;
        scene.add(buildPlateGrid);

        const boxMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });
        const boxGeometry = new THREE.BufferGeometry();
        const halfWidth = settings.plateWidth / 2;
        const halfLength = settings.plateLength / 2;
        const boxVertices = new Float32Array([
            -halfWidth, 0, -halfLength,
             halfWidth, 0, -halfLength,
             halfWidth, 0, -halfLength,
             halfWidth, 0,  halfLength,
             halfWidth, 0,  halfLength,
            -halfWidth, 0,  halfLength,
            -halfWidth, 0,  halfLength,
            -halfWidth, 0, -halfLength
        ]);
        boxGeometry.setAttribute('position', new THREE.BufferAttribute(boxVertices, 3));
        buildPlateBox = new THREE.LineSegments(boxGeometry, boxMaterial);
        scene.add(buildPlateBox);
    }

    function resizeRenderer() {
      const width = window.innerWidth;
      const height = window.innerHeight - 35;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resizeRenderer);
    resizeRenderer();

    // --- Functional Primitives & Operations ---
    function color(c, ...meshes) {
      const colorVal = new THREE.Color(c);
      const newMeshes = [];
      const applyColor = (mesh) => {
        if (mesh instanceof Brush) {
          const newMaterial = new THREE.MeshStandardMaterial({
            color: colorVal,
            metalness: 0.2,
            roughness: 0.6,
            side: THREE.DoubleSide,
            flatShading: true
          });
          mesh.material = newMaterial;
          newMeshes.push(mesh);
        } else if (mesh && mesh.isMesh) {
          const newMaterial = new THREE.MeshStandardMaterial({
            color: colorVal,
            metalness: 0.2,
            roughness: 0.6,
            side: THREE.DoubleSide,
            flatShading: true
          });
          mesh.material = newMaterial;
          newMeshes.push(mesh);
        } else if (Array.isArray(mesh)) {
          mesh.forEach(applyColor);
        }
      };
      meshes.forEach(applyColor);
      return newMeshes.length === 1 ? newMeshes[0] : newMeshes;
    }

    const ambientLight = new THREE.AmbientLight(0xffcc66, 0.5);
    scene.add(ambientLight);

    const defaultMaterial = new THREE.MeshStandardMaterial({
        color: 0xffcc00,
        metalness: 0.2,
        roughness: 0.6,
        side: THREE.DoubleSide,
        flatShading: true
    });

    function sphere({ r, d, fn } = {}) {
      if (d !== undefined) r = d / 2;
      r = r || 1;
      fn = fn || 32;
      const geom = new THREE.SphereGeometry(r, fn, fn);
      return new THREE.Mesh(geom, defaultMaterial.clone());
    }

    function cube([x = 1, y = 1, z = 1] = [1, 1, 1]) {
      const geom = new THREE.BoxGeometry(x, z, y); 
      return new THREE.Mesh(geom, defaultMaterial.clone());
    }

    function cylinder({ d, dt, db, r, rt, rb, h, fn } = {}) {
        let topRadius, bottomRadius;

        if (rt !== undefined) {
            topRadius = rt;
        }
        if (rb !== undefined) {
            bottomRadius = rb;
        }

        if (topRadius === undefined && dt !== undefined) {
            topRadius = dt / 2;
        }
        if (bottomRadius === undefined && db !== undefined) {
            bottomRadius = db / 2;
        }

        if (topRadius === undefined && bottomRadius === undefined && r !== undefined) {
            topRadius = r;
            bottomRadius = r;
        }

        if (topRadius === undefined && bottomRadius === undefined && d !== undefined) {
            topRadius = d / 2;
            bottomRadius = d / 2;
        }
        
        topRadius = topRadius || 0.5;
        bottomRadius = bottomRadius || 0.5;
        h = h || 1;
        fn = fn || 32;

        const geom = new THREE.CylinderGeometry(topRadius, bottomRadius, h, fn); 
        return new THREE.Mesh(geom, defaultMaterial.clone());
    }

    // --- Functional Transforms (Corrected for Z-up) ---
    function translate([x, y, z], mesh) {
      if (Array.isArray(x)) {
        console.warn("Translate now takes a single mesh. Please use: translate([x,y,z], mesh)");
        return x.map(m => translate([x, y, z], m));
      }
      mesh.geometry.translate(x, z, y);
      return mesh;
    }

    function rotate([x, y, z], mesh) {
      if (Array.isArray(x)) {
        console.warn("Rotate now takes a single mesh. Please use: rotate([x,y,z], mesh)");
        return x.map(m => rotate([x, y, z], m));
      }
      const tempQuaternion = new THREE.Quaternion().setFromEuler(new THREE.Euler(x, z, y));
      mesh.geometry.applyQuaternion(tempQuaternion);
      return mesh;
    }

    function scale([x, y, z], mesh) {
      if (Array.isArray(x)) {
        console.warn("Scale now takes a single mesh. Please use: scale([x,y,z], mesh)");
        return x.map(m => scale([x, y, z], m));
      }
      mesh.geometry.scale(x, y, z);
      return mesh;
    }

    function floor(mesh) {
        if (!mesh || !mesh.geometry) {
            console.warn("Floor function requires a valid mesh.");
            return mesh;
        }

        mesh.geometry.computeBoundingBox();
        const yMin = mesh.geometry.boundingBox.min.y;
        const translationY = -yMin;
        mesh.geometry.translate(0, translationY, 0);

        return mesh;
    }

    function convexHull(...meshes) {
        if (meshes.length === 0) {
            return null;
        }

        const vertices = [];
        meshes.forEach(mesh => {
            if (mesh && mesh.geometry && mesh.geometry.isBufferGeometry) {
                const positionAttribute = mesh.geometry.getAttribute('position');
                if (positionAttribute) {
                    for (let i = 0; i < positionAttribute.count; i++) {
                        const x = positionAttribute.getX(i);
                        const y = positionAttribute.getY(i);
                        const z = positionAttribute.getZ(i);
                        vertices.push(new THREE.Vector3(x, y, z));
                    }
                }
            }
        });

        if (vertices.length < 4) {
            console.warn("Convex hull requires at least 4 vertices. Returning null.");
            return null;
        }

        const hullGeometry = new ConvexGeometry(vertices);
        return new THREE.Mesh(hullGeometry, defaultMaterial.clone());
    }
    
    function align(config = {}, ...meshes) {
        const newMeshes = [];

        const alignMesh = (mesh) => {
            if (!mesh || !mesh.geometry) {
                console.warn("Align function requires a valid mesh.");
                return;
            }

            mesh.geometry.computeBoundingBox();
            const bbox = mesh.geometry.boundingBox;
            const center = new THREE.Vector3();
            bbox.getCenter(center);

            const offset = new THREE.Vector3();

            if (config.bx !== undefined) {
                offset.x = config.bx - bbox.min.x;
            } else if (config.tx !== undefined) {
                offset.x = config.tx - bbox.max.x;
            } else if (config.cx !== undefined) {
                offset.x = config.cx - center.x;
            }

            if (config.by !== undefined) {
                offset.z = config.by - bbox.min.z;
            } else if (config.ty !== undefined) {
                offset.z = config.ty - bbox.max.z;
            } else if (config.cy !== undefined) {
                offset.z = config.cy - center.z;
            }

            if (config.bz !== undefined) {
                offset.y = config.bz - bbox.min.y;
            } else if (config.tz !== undefined) {
                offset.y = config.tz - bbox.max.y;
            } else if (config.cz !== undefined) {
                offset.y = config.cz - center.y;
            }

            mesh.geometry.translate(offset.x, offset.y, offset.z);
            newMeshes.push(mesh);
        };

        meshes.forEach(alignMesh);
        return newMeshes.length === 1 ? newMeshes[0] : newMeshes;
    }

    function line3d(points2d, start, end, fn = 12) {
        if (!points2d || points2d.length < 3) {
            console.warn("line3d requires at least 3 points to form a closed shape.");
            return null;
        }

        const shape = new THREE.Shape();
        shape.moveTo(points2d[0][0], points2d[0][1]);
        for (let i = 1; i < points2d.length; i++) {
            shape.lineTo(points2d[i][0], points2d[i][1]);
        }

        const extrudePath = new THREE.LineCurve3(
            new THREE.Vector3(start[0], start[2], start[1]), 
            new THREE.Vector3(end[0], end[2], end[1])
        );

        const extrudeSettings = {
            steps: 1, 
            bevelEnabled: false,
            extrudePath: extrudePath
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        return new THREE.Mesh(geometry, defaultMaterial.clone());
    }

    function linePaths3d(points2d, points3d, fn = 12) {
        if (!points2d || points2d.length < 3) {
            console.warn("linePaths3d requires at least 3 points to form a closed 2D shape.");
            return null;
        }
        if (!points3d || points3d.length < 2) {
            console.warn("linePaths3d requires at least 2 points for the 3D extrusion path.");
            return null;
        }

        const shape = new THREE.Shape();
        shape.moveTo(points2d[0][0], points2d[0][1]);
        for (let i = 1; i < points2d.length; i++) {
            shape.lineTo(points2d[i][0], points2d[i][1]);
        }

        const extrudePath = new THREE.CurvePath();
        for (let i = 0; i < points3d.length - 1; i++) {
            const startPoint = points3d[i];
            const endPoint = points3d[i + 1];
            
            const startVector = new THREE.Vector3(startPoint[0], startPoint[2], startPoint[1]);
            const endVector = new THREE.Vector3(endPoint[0], endPoint[2], endPoint[1]);
            
            extrudePath.add(new THREE.LineCurve3(startVector, endVector));
        }

        const extrudeSettings = {
            steps: points3d.length - 1,
            bevelEnabled: false,
            extrudePath: extrudePath
        };

        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        return new THREE.Mesh(geometry, defaultMaterial.clone());
    }
    
    // Make available globally
    window.translate = translate;
    window.rotate = rotate;
    window.scale = scale;
    window.sphere = sphere;
    window.cube = cube;
    window.cylinder = cylinder;
    window.floor = floor;
    window.convexHull = convexHull;
    window.align = align;
    window.line3d = line3d;
    window.linePaths3d = linePaths3d;

    // === CSG Evaluator ===
    const csgEvaluator = new Evaluator();
    csgEvaluator.useGroups = true;

    // === Multi-Argument CSG Operations (Corrected) ===
    function union(...meshes) {
      if (meshes.length === 0) return null;
      if (meshes.length === 1) return meshes[0];
      let result = new Brush(meshes[0].geometry, meshes[0].material);
      for (let i = 1; i < meshes.length; i++) {
        const brushB = new Brush(meshes[i].geometry, meshes[i].material);
        result = csgEvaluator.evaluate(result, brushB, ADDITION);
      }
      return result;
    }

    function difference(mainMesh, ...subMeshes) {
      if (!mainMesh || subMeshes.length === 0) throw new Error('Difference: need base and one or more subtrahends');
      let result = new Brush(mainMesh.geometry, mainMesh.material);
      for (const sub of subMeshes) {
        const brushB = new Brush(sub.geometry, sub.material);
        result = csgEvaluator.evaluate(result, brushB, SUBTRACTION);
      }
      return result;
    }

    function intersect(...meshes) {
      if (meshes.length < 2) throw new Error('Intersect requires at least 2 meshes');
      let result = new Brush(meshes[0].geometry, meshes[0].material);
      for (let i = 1; i < meshes.length; i++) {
        const brushB = new Brush(meshes[i].geometry, meshes[i].material);
        result = csgEvaluator.evaluate(result, brushB, INTERSECTION);
      }
      return result;
    }

    window.union = union;
    window.difference = difference;
    window.intersect = intersect;
    window.color = color;

    // --- View Management ---
    function showView(id) {
      codePanel.style.display = 'none';
      viewPanel.style.display = 'none';
      settingsPanel.style.display = 'none';
      btn3D.style.backgroundColor = '#3498db';
      btnCode.style.backgroundColor = '#3498db';
      btnSettings.style.backgroundColor = '#3498db';
      btnLoad.style.backgroundColor = '#3498db';
      btnSave.style.backgroundColor = '#3498db';
      if (id === '3d') {
        viewPanel.style.display = 'block';
        btn3D.style.backgroundColor = '#e74c3c';
      } else if (id === 'code') {
        codePanel.style.display = 'block';
        btnCode.style.backgroundColor = '#e74c3c';
      } else if (id === 'settings') {
        settingsPanel.style.display = 'block';
        btnSettings.style.backgroundColor = '#e74c3c';
      }
    }

    btn3D.addEventListener('click', () => showView('3d'));
    btnCode.addEventListener('click', () => showView('code'));
    btnSettings.addEventListener('click', () => showView('settings'));
    
    let filePickerState = {
      isShowing: false,
      mode: null
    };
    
    let filePicker = null;

    const showFilePicker = (mode) => {
        if (filePickerState.isShowing) {
            return;
        }
        
        if (!filePicker) {
            filePicker = createfilePicker();
            filePicker.style.position = 'fixed';
            filePicker.style.top = '50%';
            filePicker.style.left = '50%';
            filePicker.style.transform = 'translate(-50%, -50%)';
            filePicker.style.width = '80%';
            filePicker.style.height = '80%';
            filePicker.style.maxWidth = '600px';
            filePicker.style.maxHeight = '800px';
            filePicker.style.zIndex = '9999';
            filePicker.addEventListener('filepick', handleFilePick);
            filePicker.addEventListener('cancel', handleFileCancel);
        }

        filePickerState.isShowing = true;
        filePickerState.mode = mode;
        document.body.appendChild(filePicker);
    };

    const hideFilePicker = () => {
        if (filePickerState.isShowing) {
            document.body.removeChild(filePicker);
            filePickerState.isShowing = false;
            filePickerState.mode = null;
        }
    };
    
    const handleFilePick = async (event) => {
        const filePath = event.detail.filePath;
        const editor = document.querySelector('#csg-code');
        const mode = filePickerState.mode;

        if (!filePath) {
            alert('File path is missing.');
            return;
        }

        try {
            if (mode === 'load') {
                const fileContent = await api.readFile(filePath);
                editor.value = fileContent;
                alert(`Code loaded successfully from: ${filePath}`);
                runCSGCode(editor);
            } else if (mode === 'save-code') {
                const codeContent = editor.value;
                await api.saveFile(filePath, codeContent);
                alert(`Code saved successfully to: ${filePath}`);
            } else if (mode === 'save-stl') {
                let finalPath = filePath;
                if (!finalPath.toLowerCase().endsWith('.stl')) {
                    finalPath += '.stl';
                }
                const stlContent = filePickerState.data;
                // Saving as a string (text) with correct headers
                await api.saveFile(finalPath, stlContent, {'Content-Type': 'text/plain'});
                alert(`STL file saved successfully to: ${finalPath}`);
            }
        } catch (error) {
            console.error(`${mode} failed:`, error);
            alert(`Failed to ${mode} file: ${error.message}`);
        } finally {
            hideFilePicker();
        }
    };

    const handleFileCancel = () => {
        alert('File operation cancelled.');
        hideFilePicker();
    };

    btnLoad.addEventListener('click', () => showFilePicker('load'));
    
    const exporter = new STLExporter();
    
    async function exportSTL() {
        if (currentObjects.length === 0) {
            alert('No objects to export!');
            return;
        }

        const exportGroup = new THREE.Group();
        currentObjects.forEach(obj => {
            if (obj.isMesh || obj instanceof Brush) {
                exportGroup.add(obj.clone());
            }
        });

        // Export as a text-based string
        const stlString = exporter.parse(exportGroup, { binary: false });

        filePickerState.data = stlString;
        showFilePicker('save-stl');
    }

    btnSave.addEventListener('click', () => {
        if (codePanel.style.display === 'block') {
            // Updated logic to save code
            showFilePicker('save-code');
        } else {
            exportSTL();
        }
    });

    saveSettingsBtn.addEventListener('click', () => {
        const newWidth = parseFloat(widthInput.value);
        const newLength = parseFloat(lengthInput.value);
        const newGridSize = parseFloat(gridSizeInput.value);

        if (isNaN(newWidth) || newWidth <= 0 || isNaN(newLength) || newLength <= 0 || isNaN(newGridSize) || newGridSize <= 0) {
            alert('Please enter valid positive numbers for all settings.');
            return;
        }

        settings.plateWidth = newWidth;
        settings.plateLength = newLength;
        settings.gridSize = newGridSize;

        localStorage.setItem('csg-editor-settings', JSON.stringify(settings));

        createBuildPlate();
        alert('Settings saved successfully!');
    });

    // --- CSG Execution ---
    let currentObjects = [];
    function runCSGCode(editor) {
      currentObjects.forEach(obj => scene.remove(obj));
      currentObjects = [];
      try {
        const code = editor.value;
        const script = new Function('sphere', 'cube', 'cylinder', 'union', 'difference', 'intersect', 'translate', 'rotate', 'scale', 'color', 'floor', 'convexHull', 'align', 'line3d', 'linePaths3d', `
          ${code}
        `);
        const result = script(sphere, cube, cylinder, union, difference, intersect, translate, rotate, scale, color, floor, convexHull, align, line3d, linePaths3d);
        if (Array.isArray(result)) {
          result.forEach(obj => {
            if (obj && (obj.isObject3D || obj instanceof Brush)) {
              scene.add(obj);
              currentObjects.push(obj);
            }
          });
        } else if (result && (result.isObject3D || result instanceof Brush)) {
          scene.add(result);
          currentObjects.push(result);
        }
        console.log('CSG executed:', result);
      } catch (err) {
        console.error('CSG Error:', err);
        alert('CSG Error:\n' + err.message);
      }
    }

    document.addEventListener('save', function (e) {
      const editor = e.target;
      if (editor && editor.id === 'csg-code') {
        runCSGCode(editor);
      }
    });

    window.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        if (codePanel.style.display === 'block') {
            // Updated logic for keyboard shortcut
            showFilePicker('save-code');
        } else if (viewPanel.style.display === 'block') {
            exportSTL();
        }
      }
    });

    // Animation Loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      const cameraDirection = new THREE.Vector3();
      camera.getWorldDirection(cameraDirection);

      keyLight.position.copy(camera.position).add(cameraDirection.multiplyScalar(-10));
      fillLight.position.copy(camera.position).add(cameraDirection.multiplyScalar(5)).add(new THREE.Vector3().set(0, 5, 0));
      backLight.position.copy(camera.position).add(cameraDirection.multiplyScalar(10));

      renderer.render(scene, camera);
    }
    animate();

    showView('3d');

    setTimeout(() => {
        const savedSettings = localStorage.getItem('csg-editor-settings');
        if (savedSettings) {
            settings = JSON.parse(savedSettings);
        }
        widthInput.value = settings.plateWidth;
        lengthInput.value = settings.plateLength;
        gridSizeInput.value = settings.gridSize;
        createBuildPlate();

        const editor = document.querySelector('#csg-code');
        const savedCode = localStorage.getItem('csg-editor-code');
        if (savedCode) editor.value = savedCode;
        runCSGCode(editor);
    }, 100);

    window.confirmClose = function () {
      if (confirm('Close editor?')) {
        showView('3d');
      }
    };
  </script>
</body>
</html>



