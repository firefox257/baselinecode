<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Bezier Curves by Distance</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            flex-direction: column;
            gap: 20px;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            background-color: #2c2c2c;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid #444;
        }

        h1 {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            text-align: center;
        }

        canvas {
            background-color: #222;
            border: 1px solid #555;
            border-radius: 8px;
            touch-action: none; /* Prevent default touch behavior */
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 400px;
        }

        .radio-group {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .radio-group label {
            cursor: pointer;
            font-size: 1rem;
            color: #ccc;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .radio-group input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #666;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        
        .radio-group input:checked {
            background-color: #66b2ff;
            border-color: #66b2ff;
        }

        label.slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #ccc;
        }

        input[type="range"] {
            width: 70%;
            -webkit-appearance: none;
            height: 8px;
            background: #444;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            border: 2px solid #66b2ff;
            box-shadow: 0 0 2px #66b2ff;
        }

        #distanceOutput {
            font-weight: bold;
            color: #66b2ff;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Bezier Curves by Distance</h1>
    <canvas id="myCanvas" width="600" height="400"></canvas>
    <div class="controls">
        <div class="radio-group">
            <label>
                <input type="radio" name="curveType" value="quadratic" checked> Quadratic
            </label>
            <label>
                <input type="radio" name="curveType" value="cubic"> Cubic
            </label>
        </div>
        <label class="slider-label" for="pointDistance">
            Distance Between Points:
            <input type="range" id="pointDistance" min="10" max="100" value="30">
            <span id="distanceOutput">30</span>
        </label>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const pointDistanceSlider = document.getElementById('pointDistance');
        const distanceOutput = document.getElementById('distanceOutput');
        const curveTypeRadios = document.querySelectorAll('input[name="curveType"]');

        const pointRadius = 6;
        const curveColor = '#888';
        const interpolatedPointColor = '#66b2ff';
        const handleColor = '#ccc';
        
        let activePoint = null;
        let curveType = 'quadratic';

        // Control points for each curve type
        const quadraticPoints = {
            p0: { x: 50, y: 350 },
            p1: { x: 300, y: 50 },
            p2: { x: 550, y: 350 }
        };

        const cubicPoints = {
            p0: { x: 50, y: 350 },
            p1: { x: 150, y: 50 },
            p2: { x: 450, y: 50 },
            p3: { x: 550, y: 350 }
        };

        // Helper function to get the correct points based on curve type
        function getPoints() {
            return curveType === 'quadratic' ? quadraticPoints : cubicPoints;
        }

        // Functions to get a point on the curve at a given t value
        function getPointOnQuadraticCurve(t, p0, p1, p2) {
            const oneMinusT = 1 - t;
            const x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
            const y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
            return { x, y };
        }

        function getPointOnCubicCurve(t, p0, p1, p2, p3) {
            const oneMinusT = 1 - t;
            const x = oneMinusT**3 * p0.x + 3 * oneMinusT**2 * t * p1.x + 3 * oneMinusT * t**2 * p2.x + t**3 * p3.x;
            const y = oneMinusT**3 * p0.y + 3 * oneMinusT**2 * t * p1.y + 3 * oneMinusT * t**2 * p2.y + t**3 * p3.y;
            return { x, y };
        }

        // Function to get the total length of the curve
        function getCurveLength(points, numSegments = 1000) {
            let totalLength = 0;
            let lastPoint = getPointOnCurve(0, points);

            for (let i = 1; i <= numSegments; i++) {
                const t = i / numSegments;
                const currentPoint = getPointOnCurve(t, points);
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
                lastPoint = currentPoint;
            }
            return totalLength;
        }

        // Unified function to get a point on the curve
        function getPointOnCurve(t, points) {
            if (curveType === 'quadratic') {
                return getPointOnQuadraticCurve(t, points.p0, points.p1, points.p2);
            } else {
                return getPointOnCubicCurve(t, points.p0, points.p1, points.p2, points.p3);
            }
        }
        
        // Main drawing function
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const points = getPoints();

            // Draw control points and handles
            drawPoint(points.p0, handleColor, 'P0');
            drawPoint(points.p1, handleColor, 'P1');
            if (curveType === 'cubic') {
                drawPoint(points.p2, handleColor, 'P2');
                drawPoint(points.p3, handleColor, 'P3');
            } else {
                drawPoint(points.p2, handleColor, 'P2');
            }
            
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = curveColor;
            ctx.moveTo(points.p0.x, points.p0.y);
            ctx.lineTo(points.p1.x, points.p1.y);
            if (curveType === 'cubic') {
                ctx.moveTo(points.p2.x, points.p2.y);
                ctx.lineTo(points.p3.x, points.p3.y);
            } else {
                 ctx.lineTo(points.p2.x, points.p2.y);
            }
            ctx.stroke();

            // Draw the main curve
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.moveTo(points.p0.x, points.p0.y);
            if (curveType === 'quadratic') {
                ctx.quadraticCurveTo(points.p1.x, points.p1.y, points.p2.x, points.p2.y);
            } else {
                ctx.bezierCurveTo(points.p1.x, points.p1.y, points.p2.x, points.p2.y, points.p3.x, points.p3.y);
            }
            ctx.stroke();

            // Draw the interpolated points
            drawInterpolatedPoints();
        }

        // Function to draw a point on the canvas
        function drawPoint(point, color, label) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(point.x, point.y, pointRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, point.x, point.y - 15);
        }

        // Function to draw points at equal distance along the curve
        function drawInterpolatedPoints() {
            const desiredDistance = parseInt(pointDistanceSlider.value);
            const points = getPoints();
            let accumulatedDistance = 0;
            let lastPoint = getPointOnCurve(0, points);

            // Always draw the first point
            drawPoint(lastPoint, interpolatedPointColor);

            // Iterate through small steps to find points at the desired distance
            const step = 0.001; // Small step for 't'
            for (let t = step; t <= 1; t += step) {
                const currentPoint = getPointOnCurve(t, points);
                const dx = currentPoint.x - lastPoint.x;
                const dy = currentPoint.y - lastPoint.y;
                const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                
                accumulatedDistance += segmentDistance;
                
                if (accumulatedDistance >= desiredDistance) {
                    drawPoint(currentPoint, interpolatedPointColor);
                    accumulatedDistance = 0; // Reset for the next point
                }
                lastPoint = currentPoint;
            }
        }

        // Event listeners for user interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const points = getPoints();
            
            for (const key in points) {
                if (isInside(mouseX, mouseY, points[key])) {
                    activePoint = points[key];
                    break;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (activePoint) {
                const rect = canvas.getBoundingClientRect();
                activePoint.x = e.clientX - rect.left;
                activePoint.y = e.clientY - rect.top;
                draw();
            }
        });

        canvas.addEventListener('mouseup', () => {
            activePoint = null;
        });

        canvas.addEventListener('mouseleave', () => {
            activePoint = null;
        });

        // Touch event listeners for mobile devices
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            const points = getPoints();
            
            for (const key in points) {
                if (isInside(touchX, touchY, points[key])) {
                    activePoint = points[key];
                    break;
                }
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (activePoint) {
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                activePoint.x = touch.clientX - rect.left;
                activePoint.y = touch.clientY - rect.top;
                draw();
            }
        });

        canvas.addEventListener('touchend', () => {
            activePoint = null;
        });

        // Helper function to check if a point is within the radius of a control point
        function isInside(x, y, point) {
            const dx = x - point.x;
            const dy = y - point.y;
            return Math.sqrt(dx * dx + dy * dy) < pointRadius * 2;
        }

        // Listen for changes on the distance slider
        pointDistanceSlider.addEventListener('input', () => {
            distanceOutput.textContent = pointDistanceSlider.value;
            draw();
        });

        // Listen for changes on the curve type radio buttons
        curveTypeRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                curveType = event.target.value;
                draw();
            });
        });

        // Initial draw
        draw();
    });
</script>

</body>
</html>