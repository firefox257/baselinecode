<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cubic Bezier Curve with OrbitControls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Inter', sans-serif;
            flex-direction: column;
            gap: 20px;
        }
        
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            touch-action: none;
        }

        #info-container {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 15px;
            background-color: rgba(44, 44, 44, 0.8);
            border-radius: 12px;
            color: #fff;
            font-size: 14px;
            width: 250px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(68, 68, 68, 0.8);
            z-index: 10;
        }

        #info-container p {
            margin: 0 0 10px 0;
            text-align: center;
        }

        #info-container label {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
        }

        #info-container input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            touch-action: auto;
        }

        #info-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            border: 2px solid #66b2ff;
            box-shadow: 0 0 2px #66b2ff;
        }

        #distanceOutput {
            font-weight: bold;
            color: #66b2ff;
        }
    </style>
</head>
<body>

<div id="info-container">
    <p>Use mouse/touch to orbit, zoom, and pan.</p>
    <p>Click and drag spheres to reshape the curve.</p>
    <label>
        Distance Between Spheres:
        <input type="range" id="pointDistance" min="0.1" max="5" step="0.1" value="1.5">
        <span id="distanceOutput">1.5</span>
    </label>
</div>

<!-- Include Three.js and OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
    window.onload = function () {
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Add OrbitControls for camera movement
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // For a smoother experience
        controls.dampingFactor = 0.05;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Grid Helper
        const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x444444);
        scene.add(gridHelper);

        // Control points
        const points = {
            p0: new THREE.Vector3(-10, 0, 0),
            p1: new THREE.Vector3(-5, 10, 5),
            p2: new THREE.Vector3(5, -10, -5),
            p3: new THREE.Vector3(10, 0, 0),
        };

        const pointHandles = [];
        const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({ color: 0x66b2ff });

        for (const key in points) {
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial.clone());
            sphere.position.copy(points[key]);
            sphere.userData = { id: key };
            pointHandles.push(sphere);
            scene.add(sphere);
        }

        // Curve lines
        const curveLineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 3 });
        const controlLineMaterial = new THREE.LineDashedMaterial({ color: 0xcccccc, dashSize: 0.5, gapSize: 0.2 });
        const curveLineGeometry = new THREE.BufferGeometry();
        const controlLineGeometry1 = new THREE.BufferGeometry().setFromPoints([points.p0, points.p1]);
        const controlLineGeometry2 = new THREE.BufferGeometry().setFromPoints([points.p2, points.p3]);

        const curveLine = new THREE.Line(curveLineGeometry, curveLineMaterial);
        const controlLine1 = new THREE.Line(controlLineGeometry1, controlLineMaterial);
        const controlLine2 = new THREE.Line(controlLineGeometry2, controlLineMaterial);
        
        controlLine1.computeLineDistances();
        controlLine2.computeLineDistances();

        scene.add(curveLine, controlLine1, controlLine2);

        // Spheres along the curve
        const interpolatedSphereGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const interpolatedSphereMaterial = new THREE.MeshPhongMaterial({ color: 0xff66b2 });
        const interpolatedSpheres = [];

        // Raycaster for picking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let activeHandle = null;

        // Function to get a point on the cubic Bezier curve
        function getPointOnCubicCurve(t, p0, p1, p2, p3) {
            const oneMinusT = 1 - t;
            const x = oneMinusT**3 * p0.x + 3 * oneMinusT**2 * t * p1.x + 3 * oneMinusT * t**2 * p2.x + t**3 * p3.x;
            const y = oneMinusT**3 * p0.y + 3 * oneMinusT**2 * t * p1.y + 3 * oneMinusT * t**2 * p2.y + t**3 * p3.y;
            const z = oneMinusT**3 * p0.z + 3 * oneMinusT**2 * t * p1.z + 3 * oneMinusT * t**2 * p2.z + t**3 * p3.z;
            return new THREE.Vector3(x, y, z);
        }

        // Function to update the curve and the interpolated spheres
        function updateCurve() {
            // Update line geometry
            const curvePoints = [];
            for (let i = 0; i <= 100; i++) {
                curvePoints.push(getPointOnCubicCurve(i / 100, points.p0, points.p1, points.p2, points.p3));
            }
            curveLine.geometry.setFromPoints(curvePoints);
            controlLine1.geometry.setFromPoints([points.p0, points.p1]);
            controlLine2.geometry.setFromPoints([points.p2, points.p3]);
            controlLine1.computeLineDistances();
            controlLine2.computeLineDistances();

            // Clear and redraw interpolated spheres
            interpolatedSpheres.forEach(sphere => scene.remove(sphere));
            interpolatedSpheres.length = 0;

            const desiredDistance = parseFloat(pointDistanceSlider.value);
            let accumulatedDistance = 0;
            let lastPoint = getPointOnCubicCurve(0, points.p0, points.p1, points.p2, points.p3);
            
            // First sphere is always at the start
            const firstSphere = new THREE.Mesh(interpolatedSphereGeometry, interpolatedSphereMaterial);
            firstSphere.position.copy(lastPoint);
            interpolatedSpheres.push(firstSphere);
            scene.add(firstSphere);

            const step = 0.001; // Small step for 't'
            for (let t = step; t <= 1; t += step) {
                const currentPoint = getPointOnCubicCurve(t, points.p0, points.p1, points.p2, points.p3);
                const segmentDistance = lastPoint.distanceTo(currentPoint);
                accumulatedDistance += segmentDistance;

                if (accumulatedDistance >= desiredDistance) {
                    const newSphere = new THREE.Mesh(interpolatedSphereGeometry, interpolatedSphereMaterial);
                    newSphere.position.copy(currentPoint);
                    interpolatedSpheres.push(newSphere);
                    scene.add(newSphere);
                    accumulatedDistance = 0; // Reset for the next point
                }
                lastPoint = currentPoint;
            }
        }
        
        // --- Event Listeners for Interaction ---

        // Dragging
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);

        // Touch events for mobile
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        
        const dragPlane = new THREE.Plane();
        const dragOffset = new THREE.Vector3();

        function onMouseDown(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointHandles);

            if (intersects.length > 0) {
                isDragging = true;
                activeHandle = intersects[0].object;
                
                // Set the plane for dragging and disable controls
                controls.enabled = false;
                raycaster.ray.intersectPlane(dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), activeHandle.position), dragOffset);
                activeHandle.material.color.setHex(0xff0000); // Highlight active handle
            }
        }
        
        function onMouseMove(event) {
            if (isDragging && activeHandle) {
                event.preventDefault();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersection);
                
                activeHandle.position.copy(intersection.sub(dragOffset));
                points[activeHandle.userData.id] = activeHandle.position;
                
                updateCurve();
            }
        }
        
        function onMouseUp() {
            if (activeHandle) {
                activeHandle.material.color.setHex(0x66b2ff);
            }
            isDragging = false;
            activeHandle = null;
            controls.enabled = true; // Re-enable controls
        }

        // --- Touch Events for Mobile ---
        function onTouchStart(event) {
            if (event.touches.length > 1) {
                // If two fingers, treat as camera control
                isDragging = false;
                activeHandle = null;
                controls.enabled = true;
                return;
            }
            event.preventDefault();
            const touch = event.touches[0];
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointHandles);

            if (intersects.length > 0) {
                isDragging = true;
                activeHandle = intersects[0].object;
                controls.enabled = false; // Disable controls for dragging
                raycaster.ray.intersectPlane(dragPlane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(dragPlane.normal), activeHandle.position), dragOffset);
                activeHandle.material.color.setHex(0xff0000);
            }
        }

        function onTouchMove(event) {
            if (isDragging && activeHandle && event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersection = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersection);
                
                activeHandle.position.copy(intersection.sub(dragOffset));
                points[activeHandle.userData.id] = activeHandle.position;
                updateCurve();
            }
        }
        
        function onTouchEnd(event) {
            if (activeHandle) {
                activeHandle.material.color.setHex(0x66b2ff);
            }
            isDragging = false;
            activeHandle = null;
            controls.enabled = true; // Re-enable controls
        }
        
        // Slider control
        const pointDistanceSlider = document.getElementById('pointDistance');
        const distanceOutput = document.getElementById('distanceOutput');
        pointDistanceSlider.addEventListener('input', () => {
            distanceOutput.textContent = pointDistanceSlider.value;
            updateCurve();
        });

        // Resize handler
        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Update controls in every frame
            renderer.render(scene, camera);
        }

        // Initial setup
        updateCurve();
        animate();
    };
</script>
</body>
</html>