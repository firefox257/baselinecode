<!--

take out the fire fly code. make the page have a fog effect in webgl. use the reference code in the canvas code to do a the same fog effect in webgl. 
don't change the background aspict ratio itnis fine as it is.

-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Screen WebGL Background with 3D Fireflies</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        // --- Utility for Matrix Operations (Simplified) ---
        // For more robust matrix math, you'd typically use a library like gl-matrix
        const mat4 = {
            create: () => new Float32Array(16),
            identity: (out) => {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            perspective: (out, fovy, aspect, near, far) => {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (near + far) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
                return out;
            },
            multiply: (out, a, b) => {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                return out;
            },
             // Simple translation for view matrix (adjusted for camera inverse logic)
            translateView: (out, a, v) => {
                let x = v[0], y = v[1], z = v[2];
                let a00=a[0], a01=a[1], a02=a[2], a03=a[3];
                let a10=a[4], a11=a[5], a12=a[6], a13=a[7];
                let a20=a[8], a21=a[9], a22=a[10], a23=a[11];
                let a30=a[12], a31=a[13], a32=a[14], a33=a[15];

                out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
                out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
                out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

                // For a view matrix, we effectively translate the world, not the camera directly.
                // So, if the camera moves +Z, the world moves -Z relative to the camera.
                out[12] = a00 * (-x) + a10 * (-y) + a20 * (-z) + a30;
                out[13] = a01 * (-x) + a11 * (-y) + a21 * (-z) + a31;
                out[14] = a02 * (-x) + a12 * (-y) + a22 * (-z) + a32;
                out[15] = a03 * (-x) + a13 * (-y) + a23 * (-z) + a33;
                return out;
            }
        };


        window.onload = function() {
            const canvas = document.getElementById('glCanvas');
            const gl = canvas.getContext('webgl');

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            // Set canvas to full screen
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // --- Background Shaders ---
            const backgroundVsSource = `
                attribute vec4 aVertexPosition;
                attribute vec2 aTexCoord;

                uniform mat4 uProjectionMatrix;
                uniform mat4 uViewMatrix; 

                varying highp vec2 vTexCoord;

                void main(void) {
                    gl_Position = uProjectionMatrix * uViewMatrix * aVertexPosition;
                    vTexCoord = aTexCoord;
                }
            `;

            const backgroundFsSource = `
                varying highp vec2 vTexCoord;
                uniform sampler2D uSampler;

                void main(void) {
                    gl_FragColor = texture2D(uSampler, vTexCoord);
                }
            `;

            // --- Firefly Shaders ---
            const fireflyVsSource = `
                attribute vec3 aPosition; // Now vec3 for 3D position
                attribute float aSize;
                attribute float aRandom;
                uniform float uTime;
                uniform vec2 uResolution;
                uniform mat4 uProjectionMatrix;
                uniform mat4 uViewMatrix;

                varying highp float vAlpha;

                void main() {
                    // 3D random walk for fireflies
                    vec3 offset = vec3(
                        sin(uTime * 0.7 + aRandom * 12.0) * aRandom,  // Faster X movement
                        cos(uTime * 0.9 + aRandom * 7.0) * aRandom,   // Faster Y movement
                        sin(uTime * 0.5 + aRandom * 18.0) * aRandom   // Faster Z movement
                    );
                    // MODIFIED: Increased movement factor for more noticeable "flying"
                    vec3 animatedPosition = aPosition + offset * 0.2; // Changed from 0.08 to 0.2

                    // Apply projection and view matrices
                    gl_Position = uProjectionMatrix * uViewMatrix * vec4(animatedPosition, 1.0);

                    // Scale point size based on depth (closer = larger, farther = smaller)
                    // clamped to avoid negative or overly large scale
                    float depthScale = 1.0 + (animatedPosition.z + 1.0) * 0.5;
                    gl_PointSize = (aSize * depthScale) * (uResolution.y / 800.0);

                    // Vary alpha for flickering effect
                    vAlpha = 0.5 + 0.5 * sin(uTime * 10.0 + aRandom * 20.0);
                }
            `;

            const fireflyFsSource = `
                precision mediump float;

                varying highp float vAlpha;

                void main() {
                    vec2 coord = gl_PointCoord - 0.5;
                    float dist = length(coord);
                    float alpha = smoothstep(0.5, 0.0, dist);

                    vec3 color = vec3(1.0, 0.9, 0.4);
                    color *= (0.8 + 0.2 * sin(vAlpha * 5.0));

                    gl_FragColor = vec4(color, alpha * vAlpha);
                }
            `;


            // --- Shader Program Utilities ---
            function initShaderProgram(gl, vsSource, fsSource, programName) {
                const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource, programName + ' Vertex');
                const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource, programName + ' Fragment');

                if (!vertexShader || !fragmentShader) return null;

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error(`Unable to initialize ${programName} shader program:`, gl.getProgramInfoLog(shaderProgram));
                    alert(`Unable to initialize ${programName} shader program. Check console for details.`);
                    return null;
                }
                return shaderProgram;
            }

            function loadShader(gl, type, source, shaderName) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(`An error occurred compiling ${shaderName} shader:`, gl.getShaderInfoLog(shader));
                    alert(`An error occurred compiling ${shaderName} shader. Check console for details.`);
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            // --- Background Setup ---
            const backgroundShaderProgram = initShaderProgram(gl, backgroundVsSource, backgroundFsSource, 'Background');
            if (!backgroundShaderProgram) return;
            const backgroundProgramInfo = {
                program: backgroundShaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(backgroundShaderProgram, 'aVertexPosition'),
                    texCoord: gl.getAttribLocation(backgroundShaderProgram, 'aTexCoord'),
                },
                uniformLocations: {
                    uSampler: gl.getUniformLocation(backgroundShaderProgram, 'uSampler'),
                    uProjectionMatrix: gl.getUniformLocation(backgroundShaderProgram, 'uProjectionMatrix'),
                    uViewMatrix: gl.getUniformLocation(backgroundShaderProgram, 'uViewMatrix'),
                },
            };

            // MODIFIED: initBackgroundBuffers now accepts imageAspect
            function initBackgroundBuffers(gl, imageAspect) {
                let positions;
                // Adjust the quad's dimensions to match the image's aspect ratio
                // We assume the background will be placed such that it fills the view (e.g., at Z=-10 or similar)
                // and the camera's FOV will handle the final fit to screen.
                // Here, we ensure the quad's own width/height ratio matches the image.
                if (imageAspect > 1) { // Image is wider than it is tall
                    positions = new Float32Array([
                        -imageAspect,  1.0, 0.0, // Top-left
                         imageAspect,  1.0, 0.0, // Top-right
                        -imageAspect, -1.0, 0.0, // Bottom-left
                         imageAspect, -1.0, 0.0,  // Bottom-right
                    ]);
                } else { // Image is taller than it is wide, or square
                    positions = new Float32Array([
                        -1.0,  1.0 / imageAspect, 0.0, // Top-left
                         1.0,  1.0 / imageAspect, 0.0, // Top-right
                        -1.0, -1.0 / imageAspect, 0.0, // Bottom-left
                         1.0, -1.0 / imageAspect, 0.0,  // Bottom-right
                    ]);
                }


                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const textureCoordinates = new Float32Array([
                    0.0,  0.0,  // Top-left
                    1.0,  0.0,  // Top-right
                    0.0,  1.0,  // Bottom-left
                    1.0,  1.0,  // Bottom-right
                ]);

                const textureCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);

                const indices = new Uint16Array([
                    0, 1, 2,    // Triangle 1
                    1, 3, 2,    // Triangle 2
                ]);

                const indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                return {
                    position: positionBuffer,
                    texCoord: textureCoordBuffer,
                    indices: indexBuffer,
                };
            }
            // MODIFIED: backgroundBuffers is now initialized after the texture loads
            let backgroundBuffers = null; // Will be set once texture dimensions are known

            function loadTexture(gl, url) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                // Placeholder 1x1 blue pixel while image loads
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]));

                const image = new Image();
                image.onload = function() {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                       gl.generateMipmap(gl.TEXTURE_2D);
                    } else {
                       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                    console.log(`Texture '${url}' loaded: ${image.width}x${image.height}`);
                    texture.imageWidth = image.width;
                    texture.imageHeight = image.height;

                    // MODIFIED: Initialize background buffers here with the actual image aspect
                    const imageAspect = image.width / image.height;
                    backgroundBuffers = initBackgroundBuffers(gl, imageAspect);
                };
                image.onerror = function() {
                    console.error(`Failed to load texture: ${url}`);
                };
                image.src = url;
                return texture;
            }

            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
            }
            const backgroundTexture = loadTexture(gl, 'background.png'); // Trigger texture load

            // --- Firefly Setup ---
            const fireflyShaderProgram = initShaderProgram(gl, fireflyVsSource, fireflyFsSource, 'Firefly');
            if (!fireflyShaderProgram) return;
            const fireflyProgramInfo = {
                program: fireflyShaderProgram,
                attribLocations: {
                    position: gl.getAttribLocation(fireflyShaderProgram, 'aPosition'),
                    size: gl.getAttribLocation(fireflyShaderProgram, 'aSize'),
                    random: gl.getAttribLocation(fireflyShaderProgram, 'aRandom'),
                },
                uniformLocations: {
                    uTime: gl.getUniformLocation(fireflyShaderProgram, 'uTime'),
                    uResolution: gl.getUniformLocation(fireflyShaderProgram, 'uResolution'),
                    uProjectionMatrix: gl.getUniformLocation(fireflyShaderProgram, 'uProjectionMatrix'),
                    uViewMatrix: gl.getUniformLocation(fireflyShaderProgram, 'uViewMatrix'),
                },
            };

            const pointSizeRange = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
            console.log("Supported point size range:", pointSizeRange);

            const NUM_FIREFLIES = 400; // Increased number for better density with smaller size
            let fireflyPositions = [];
            let fireflySizes = [];
            let fireflyRandoms = [];

            function initFireflyData() {
                for (let i = 0; i < NUM_FIREFLIES; i++) {
                    // Spread fireflies more across Z to show depth scaling
                    fireflyPositions.push(Math.random() * 2 - 1); // X (-1 to 1)
                    fireflyPositions.push(Math.random() * 2 - 1); // Y (-1 to 1)
                    fireflyPositions.push(Math.random() * 4 - 2); // Z (-2 to 2) - wider range
                    // Much smaller size range for delicate fireflies
                    fireflySizes.push(1 + Math.random() * 3); // Size 1 to 4 pixels
                    fireflyRandoms.push(Math.random());
                }
                console.log("Initialized", NUM_FIREFLIES, "fireflies with 3D positions.");
            }
            initFireflyData();

            const fireflyPositionBuffer = gl.createBuffer();
            const fireflySizeBuffer = gl.createBuffer();
            const fireflyRandomBuffer = gl.createBuffer();

            function updateFireflyBuffers() {
                gl.bindBuffer(gl.ARRAY_BUFFER, fireflyPositionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(fireflyPositions), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, fireflySizeBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(fireflySizes), gl.STATIC_DRAW);

                gl.bindBuffer(gl.ARRAY_BUFFER, fireflyRandomBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(fireflyRandoms), gl.STATIC_DRAW);
            }
            updateFireflyBuffers();


            let lastTime = 0;
            const fieldOfView = 45 * Math.PI / 180;
            const zNear = 0.1;
            const zFar = 100.0;

            const projectionMatrix = mat4.create(); // This will be the base projection matrix for the scene
            const viewMatrix = mat4.create();

            // --- Drawing Function ---
            function drawScene(now) {
                now *= 0.001;
                const deltaTime = now - lastTime;
                lastTime = now;

                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clearDepth(1.0);
                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                const canvasAspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
                mat4.perspective(projectionMatrix, fieldOfView, canvasAspect, zNear, zFar); // Base projection for the whole scene

                mat4.identity(viewMatrix);
                // Translate the world back to simulate camera moving forward (positive Z camera -> negative Z world)
                // Moved background further back, so camera needs to be further back too.
                mat4.translateView(viewMatrix, viewMatrix, [0.0, 0.0, 5.0]);

                gl.disable(gl.BLEND); // Disable blending for opaque background

                // --- Draw Background ---
                gl.useProgram(backgroundProgramInfo.program);

                // Now that the background geometry itself matches the image aspect,
                // we can just use the standard projection matrix.
                gl.uniformMatrix4fv(backgroundProgramInfo.uniformLocations.uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(backgroundProgramInfo.uniformLocations.uViewMatrix, false, viewMatrix);

                // MODIFIED: Only draw background if its buffers have been initialized (i.e., texture loaded)
                if (backgroundBuffers) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, backgroundBuffers.position);
                    gl.vertexAttribPointer(
                        backgroundProgramInfo.attribLocations.vertexPosition,
                        3, gl.FLOAT, false, 0, 0
                    );
                    gl.enableVertexAttribArray(backgroundProgramInfo.attribLocations.vertexPosition);

                    gl.bindBuffer(gl.ARRAY_BUFFER, backgroundBuffers.texCoord);
                    gl.vertexAttribPointer(
                        backgroundProgramInfo.attribLocations.texCoord,
                        2, gl.FLOAT, false, 0, 0
                    );
                    gl.enableVertexAttribArray(backgroundProgramInfo.attribLocations.texCoord);

                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, backgroundTexture);
                    gl.uniform1i(backgroundProgramInfo.uniformLocations.uSampler, 0);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, backgroundBuffers.indices);
                    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
                }

                // For debugging, only enable if needed
                // let error = gl.getError();
                // if (error !== gl.NO_ERROR) {
                //     console.error('WebGL Error after drawing background:', error);
                // }


                // --- Draw Fireflies ---
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // Additive blending for glow effect

                gl.useProgram(fireflyProgramInfo.program);

                // For fireflies, use the regular (unscaled) projection matrix based on canvas aspect
                gl.uniformMatrix4fv(fireflyProgramInfo.uniformLocations.uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(fireflyProgramInfo.uniformLocations.uViewMatrix, false, viewMatrix);

                gl.uniform1f(fireflyProgramInfo.uniformLocations.uTime, now);
                gl.uniform2f(fireflyProgramInfo.uniformLocations.uResolution, canvas.width, canvas.height);


                gl.bindBuffer(gl.ARRAY_BUFFER, fireflyPositionBuffer);
                gl.vertexAttribPointer(
                    fireflyProgramInfo.attribLocations.position,
                    3, gl.FLOAT, false, 0, 0
                );
                gl.enableVertexAttribArray(fireflyProgramInfo.attribLocations.position);

                gl.bindBuffer(gl.ARRAY_BUFFER, fireflySizeBuffer);
                gl.vertexAttribPointer(
                    fireflyProgramInfo.attribLocations.size,
                    1, gl.FLOAT, false, 0, 0
                );
                gl.enableVertexAttribArray(fireflyProgramInfo.attribLocations.size);

                gl.bindBuffer(gl.ARRAY_BUFFER, fireflyRandomBuffer);
                gl.vertexAttribPointer(
                    fireflyProgramInfo.attribLocations.random,
                    1, gl.FLOAT, false, 0, 0
                );
                gl.enableVertexAttribArray(fireflyProgramInfo.attribLocations.random);

                gl.drawArrays(gl.POINTS, 0, NUM_FIREFLIES);

                // For debugging, only enable if needed
                // error = gl.getError();
                // if (error !== gl.NO_ERROR) {
                //     console.error('WebGL Error after drawing fireflies:', error);
                // }

                requestAnimationFrame(drawScene);
            }

            requestAnimationFrame(drawScene);
        };
    </script>
</body>
</html>
