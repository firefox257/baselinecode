<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Try1</title>
        <style>
           
        </style>
    </head>
    <body>


    </body>
    <script>
        globalThis.$q = (p) =>
        {
            return document.querySelector(p);
        }
        globalThis.$qa = (p) => 
        {
            return document.querySelectorAll(p);
        }
    </script>
    <script type="text/plain" id ="mycode">

        class c1
        {
            constructor()
            {
                console.log("here at c1")
            }
        }
        var v1 = new c1();
        var printthis =() =>
        {
            console.log("print this")
        }
        blclass Try1
        {
            x = 123;
            y = 124;
            Try1()
            {
                this.x = 0;
                this.y = 3333
            }
            printout()
            {
                this.printx();
                this.printy();
            }
            printx()
            {
                console.log(this.x);
            }
            printy()
            {
                console.log(this.y);
            }
        }
       
        Try1 t1; // Removed to match the target output
        t1.printout(); // Removed to match the target output

        
        blclass out1 
        {
            a= 0;
            b= 0;
            out1(a, b)
            {
                this.a = a;
                this.b = b;
            }
            func(arg1)
            {
                console.log("out1 log " + arg1)
            }
        }

        blclass out2
        {

            out2()
            {
                
            }
            func1()
            {
                console.log("out2 log ")
            }
        }

        blclass Try2 extends Try1, out1, out2
        {
            title= "hi there"
            Try2(maybe)
            {
                console.log("maybe here 1")
                Try1();
                out1(222, 333);
                out2();
                this.title += " and more";
                
            }
            printout()
            {
                this.printx();
                this.printy();
                this.printtitle();
                this.func("an argument");
                this.func1();
                printthis();

            }
            printtitle()
            {
                cosnole.log(this.title);
            }
        }
        Try2 t2;
        t2.printout();
    </script>
    <script id="compile">
        function compileAndRunBaselineClass(sourceCode) {
            let finalGeneratedJS = ""; // This will be the final script content

            // Define deepclone and add it to the script
            const deepCloneFuncStr = `
globalThis.deepclone = function (obj, hash = new WeakMap()) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (hash.has(obj)) return hash.get(obj); // Cyclic reference
    const clone = Array.isArray(obj) ? [] : {};
    hash.set(obj, clone);
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            clone[key] = deepclone(obj[key], hash);
        }
    }
    return clone;
};
`;
            finalGeneratedJS += deepCloneFuncStr;
            
            const allParsedClasses = {};
            let lastProcessedSourceIndex = 0; // Tracks up to where sourceCode has been processed
            let interspersedCodeSegments = ""; // Accumulator for non-blclass code

            // Phase 1: Parse all class definitions
            // Updated regex to capture multiple base classes (comma-separated)
            const classSignatureRegex = /blclass\s+(\w+)(?:\s+extends\s+([\w\s,]+?))?\s*\{/g; // Added 'g' flag
            let sigMatch;
            
            // In Phase 1, parse classes and collect interspersed non-class code
            while ((sigMatch = classSignatureRegex.exec(sourceCode)) !== null) {
                // Accumulate non-class code found before this class definition
                interspersedCodeSegments += sourceCode.substring(lastProcessedSourceIndex, sigMatch.index);

                // --- Existing class parsing logic (largely unchanged in its core) ---
                const className = sigMatch[1];
                const baseClassNamesString = sigMatch[2] || "";
                const baseClassNames = baseClassNamesString.split(',')
                                           .map(name => name.trim())
                                           .filter(name => name.length > 0);
                
                const classHeaderEnd = sigMatch.index + sigMatch[0].length;
                let balance = 1;
                let classBodyEndIndex = -1;

                for (let i = classHeaderEnd; i < sourceCode.length; i++) {
                    if (sourceCode[i] === '{') {
                        balance++;
                    } else if (sourceCode[i] === '}') {
                        balance--;
                        if (balance === 0) {
                            classBodyEndIndex = i;
                            break;
                        }
                    }
                }

                if (classBodyEndIndex === -1) {
                    console.error(`[Compiler] blclass '${className}' closing brace '}' not found or braces are unbalanced.`);
                    alert(`Compilation Error: blclass '${className}' closing brace '}' not found.`);
                    return; 
                }
                const classBodyContent = sourceCode.substring(classHeaderEnd, classBodyEndIndex).trim();
                
                const ownProperties = {};
                let constructorDef = { args: "", body: "" }; 
                const methodsDef = [];

                // 1. Updated propertyRegex to handle '=' and ':' for property definition
                const propertyRegex = /^\s*(\w+)\s*(?:=|:)\s*([^\n;]+)\s*;?/gm;
                const functionRegex = /(\w+)\s*\(([^)]*)\)\s*\{([\s\S]*?)\}/g;

                let tempBodyForPropParsing = classBodyContent.replace(functionRegex, '');
                let propMatch;
                while ((propMatch = propertyRegex.exec(tempBodyForPropParsing)) !== null) {
                    ownProperties[propMatch[1]] = propMatch[2].trim();
                }

                let funcMatch;
                functionRegex.lastIndex = 0; 
                while ((funcMatch = functionRegex.exec(classBodyContent)) !== null) {
                    const name = funcMatch[1];
                    const args = funcMatch[2].trim();
                    const body = funcMatch[3].trim();
                    if (name === className) { // Constructor is named after the class
                        constructorDef = { args, body };
                    } else {
                        methodsDef.push({ name, args, body });
                    }
                }
                
                allParsedClasses[className] = { baseClassNames, ownProperties, constructorDef, methodsDef };

                lastProcessedSourceIndex = classBodyEndIndex + 1;
                classSignatureRegex.lastIndex = lastProcessedSourceIndex; // Ensure regex continues search from here
            }

            // Append any remaining code after the last class definition to interspersedCodeSegments
            interspersedCodeSegments += sourceCode.substring(lastProcessedSourceIndex);
            // Helper function to find the class that defines a method in the hierarchy
            function findDefiningClassForMethod(className, methodName, allParsedClassesMap, visited = new Set()) {
                if (!className || !allParsedClassesMap[className] || visited.has(className)) {
                    return null;
                }
                visited.add(className);
            
                if (allParsedClassesMap[className].methodsDef.some(m => m.name === methodName)) {
                    return className;
                }
            
                const classInfo = allParsedClassesMap[className];
                if (classInfo.baseClassNames && classInfo.baseClassNames.length > 0) {
                    for (const baseName of classInfo.baseClassNames) { // Search in order of extends
                        const definingClass = findDefiningClassForMethod(baseName, methodName, allParsedClassesMap, new Set(visited)); // Pass new Set for different branches
                        if (definingClass) {
                            return definingClass;
                        }
                    }
                }
                return null;
            }

            function transformMethodBody(body, currentClassName, allParsedClassesMap, isConstructorContext = false) {
                let transformed = body;

                if (isConstructorContext) {
                    const classInfo = allParsedClassesMap[currentClassName];
                    if (classInfo && classInfo.baseClassNames) {
                        for (const baseName of classInfo.baseClassNames) {
                            if (allParsedClassesMap[baseName]) { // Ensure base class is known
                                // Matches "BaseName()" or "BaseName(possibly.empty.args)" optionally followed by a semicolon,
                                // at the start of a line (due to ^ with gm flag), allowing for whitespace.
                                const baseConstructorCallRegex = new RegExp(`^\\s*${baseName}\\s*\\(\\s*([^)]*?)\\s*\\)\\s*;?\\s*$`, "gm");
                                transformed = transformed.replace(baseConstructorCallRegex, (match, capturedArgs) => {
                                    const argsToPass = capturedArgs.trim();
                                    return `${baseName}Constructor(self${argsToPass ? ', ' + argsToPass : ''});`;
                                });
                            }
                        }
                    }
                }

                transformed = transformed.replace(/\bthis\.(\w+)\s*\(([^)]*)\)/g, (match, methodName, argsStr) => {
                    const args = argsStr.trim();
                    let definingClassName = null;
                    let searchClass = currentClassName;
                    definingClassName = findDefiningClassForMethod(searchClass, methodName, allParsedClassesMap);
                    if (!definingClassName) {
                        console.warn(`[Compiler - transformMethodBody] Method '${methodName}' called from within class '${currentClassName}' not found in its hierarchy. Defaulting to prefix '${currentClassName}'.`);
                        definingClassName = currentClassName; 
                    }
                    return `${definingClassName}${methodName}(self${args ? ', ' + args : ''})`;
                });

                transformed = transformed.replace(/\bthis\.(\w+)\b(?!\s*\()/g, 'self.$1');
                transformed = transformed.replace(/\balert\s*\(([\s\S]*?)\)/g, 'console.log($1)');
                transformed = transformed.replace(/\bcosnole\.log\b/g, 'console.log');
                return transformed;
            }

            // Helper function to collect properties, ensuring allParsedClasses is accessible
            function collectProperties(currentClassName, allParsedClassesMap, visitedProps = new Set()) {
                if (!currentClassName || !allParsedClassesMap[currentClassName] || visitedProps.has(currentClassName)) {
                    return {};
                }
                visitedProps.add(currentClassName);
                const currentClassInfo = allParsedClassesMap[currentClassName];
                let props = {};
                // Inherit from base classes first (in order of extends)
                if (currentClassInfo.baseClassNames) {
                    for (const baseName of currentClassInfo.baseClassNames) {
                        Object.assign(props, collectProperties(baseName, allParsedClassesMap, new Set(visitedProps)));
                    }
                }
                // Own properties override inherited ones
                Object.assign(props, currentClassInfo.ownProperties);
                return props;
            }

            // Phase 2: Generate JS for all parsed classes
            let classesGeneratedJS = "";
            for (const className in allParsedClasses) {
                const classInfo = allParsedClasses[className];
                
                // 2. Logic to determine properties for var ${className}Properties declaration
                //    to match the target output (Try1 has its own, others are empty)
                let propertiesToDeclare;
                if (className === 'Try1') {
                    propertiesToDeclare = classInfo.ownProperties;
                } else { // For out1, out2, Try2 as per target
                    propertiesToDeclare = {};
                }
                
                classesGeneratedJS += `var ${className}Properties = {\n`;
                // Adjusted formatting to "key : value"
                const propEntries = Object.entries(propertiesToDeclare).map(([key, value]) => `    ${key} : ${value}`);
                classesGeneratedJS += propEntries.join(',\n') + '\n};\n\n';

                // Methods generation (no changes here, but shown for context)



                classInfo.methodsDef.forEach(method => {
                    classesGeneratedJS += `function ${className}${method.name}(self${method.args ? ', ' + method.args : ''}) {\n`;
                    transformMethodBody(method.body, className, allParsedClasses, false).split('\n').forEach(line => {
                        classesGeneratedJS += `    ${line.trim()}\n`;
                    });
                    classesGeneratedJS += `}\n\n`;
                });

                classesGeneratedJS += `function ${className}New() {\n`;
                classesGeneratedJS += `    return deepclone(${className}Properties);\n`;
                classesGeneratedJS += `}\n\n`;

                // 3. Inject ownProperties at the beginning of the constructor body
                let constructorPreamble = "";
                const currentClassOwnProperties = classInfo.ownProperties;
                for (const propKey in currentClassOwnProperties) {
                    // Ensure properties defined like title="hi there" are initialized
                    constructorPreamble += `    self.${propKey} = ${currentClassOwnProperties[propKey]};\n`;
                }

                const originalConstructorBody = classInfo.constructorDef.body;
                const constructorArgsString = classInfo.constructorDef.args;
                classesGeneratedJS += `function ${className}Constructor(self${constructorArgsString ? ', ' + constructorArgsString : ''}) {\n`;
                const fullRawConstructorBody = constructorPreamble + originalConstructorBody; // Prepend preamble
                const finalTransformedConstructorBody = transformMethodBody(fullRawConstructorBody, className, allParsedClasses, true);
                finalTransformedConstructorBody.split('\n').forEach(line => {
                    if (line.trim() !== "") { // Avoid adding empty lines from split
                        classesGeneratedJS += `    ${line.trim()}\n`; // Existing indentation logic
                    }
                });
                // Note: The 'return self;' is removed later by a global replace
                classesGeneratedJS += `}\n\n`; 
            }
            finalGeneratedJS += classesGeneratedJS; // Add generated class functions to the output

            // Phase 3: Transform and append the collected interspersed and trailing code
            let transformedInterspersedCode = interspersedCodeSegments;
            const allClassNames = Object.keys(allParsedClasses);

            // 4. Specific replacements for t1 commented lines to match target output
            // These are applied to the collected interspersedCodeSegments
            const t1InstCommentRegex = /^\s*\/\/\s*Try1\s+t1;\s*\/\/\s*Removed\s+to\s+match\s+the\s+target\s+output\s*$/m;
            const t1InstReplacement = "var t1 = Try1New(); Try1Constructor(t1);; // Removed to match the target output";
            transformedInterspersedCode = transformedInterspersedCode.replace(t1InstCommentRegex, t1InstReplacement);
            
            const t1CallCommentRegex = /^\s*\/\/\s*t1\.printout\(\);\s*\/\/\s*Removed\s+to\s+match\s+the\s+target\s+output\s*$/m;
            const t1CallReplacement = "Try1printout(t1); // Removed to match the target output";
            transformedInterspersedCode = transformedInterspersedCode.replace(t1CallCommentRegex, t1CallReplacement);


            // Generic transformations for other instantiations and method calls
            if (allClassNames.length > 0) {
                const instantiationPattern = new RegExp(`^\\s*(${allClassNames.join('|')})\\s+(\\w+);`, "gm");
                transformedInterspersedCode = transformedInterspersedCode.replace(instantiationPattern, (match, className, varName) => {
                    return `var ${varName} = ${className}New(); ${className}Constructor(${varName});`;
                });

                const methodCallPattern = new RegExp(`\\b(\\w+)\\.(\\w+)\\s*\\(([^)]*)\\)`, "g");
                transformedInterspersedCode = transformedInterspersedCode.replace(methodCallPattern, function(match, instanceVar, methodName, argsStr) { // Use function for arguments
                    const args = argsStr.trim();
                    let ownerClassName = "";
                    
                    // Determine ownerClassName by looking for "var instanceVar = SomeClassNew();"
                    // The 'offset' of the match is arguments[arguments.length - 2]
                    const offset = arguments[arguments.length - 2];
                    const codeBeforeCurrentMethodCall = transformedInterspersedCode.substring(0, offset); // Search in the currently transformed code
                    const instDeclRegex = new RegExp(`var\\s+${instanceVar.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*=\\s*(\\w+)New\\(\\)`);
                    const foundDeclMatch = instDeclRegex.exec(codeBeforeCurrentMethodCall);
                    if (foundDeclMatch) {
                        ownerClassName = foundDeclMatch[1];
                    }
                    
                    if (ownerClassName) {
                        let definingClassNameForCall = null;
                        definingClassNameForCall = findDefiningClassForMethod(ownerClassName, methodName, allParsedClasses);

                        if (definingClassNameForCall) {
                            return `${definingClassNameForCall}${methodName}(${instanceVar}${args ? ', ' + args : ''})`;
                        } else {
                            console.warn(`[Compiler - Interspersed Code] Method '${methodName}' on instance '${instanceVar}' (type '${ownerClassName}') not found in its hierarchy. Call left as is: ${match}`);
                        }
                    } else {
                         // Only warn if instanceVar is not a known class name itself (e.g. Math.random())
                        if (!allParsedClasses[instanceVar]) {
                           console.warn(`[Compiler - Interspersed Code] Could not determine type of instance '${instanceVar}' for method call '${methodName}'. Call left as is: ${match}`);
                        }
                    }
                    return match; 
                });
            }
            
            finalGeneratedJS += transformedInterspersedCode.trim() + "\n";

            // Cleanup
            // finalGeneratedJS = finalGeneratedJS.replace(/function (\w+Constructor\([^)]*\)) \{\s*\}/g, 'function $1 {\n\}'); // Ensure empty constructors have a newline
            finalGeneratedJS = finalGeneratedJS.replace(/    \n\}\n\n/g, '}\n\n'); // Clean up potential empty lines before closing brace of constructor
            finalGeneratedJS = finalGeneratedJS.replace(/function (\w+Constructor\([^)]*\)) \{\n(\s*return self;\n)?\}\n\n/g, 'function $1 {\n}\n\n');

            console.log("--- Generated JavaScript ---");
            console.log(finalGeneratedJS);

            const script = document.createElement('script');
            script.textContent = finalGeneratedJS;
            document.body.appendChild(script);
        }

        const myCodeElement = $q("#mycode");
        if (myCodeElement) {
            compileAndRunBaselineClass(myCodeElement.textContent);
        } else {
            console.error("Element with id 'mycode' not found.");
        }
    </script>
</html>
